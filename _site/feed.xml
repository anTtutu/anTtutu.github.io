<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Anttu</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 Feb 2020 00:38:03 +0800</pubDate>
    <lastBuildDate>Wed, 12 Feb 2020 00:38:03 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Golang学习笔记 - 关键字和基础数据类型介绍</title>
        <description>&lt;h4 id=&quot;记录自己的golang学习笔记&quot;&gt;记录自己的Golang学习笔记&lt;/h4&gt;

&lt;h1 id=&quot;一golang关键字和介绍&quot;&gt;一、Golang关键字和介绍&lt;/h1&gt;
&lt;h2 id=&quot;25个关键字&quot;&gt;25个关键字:&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;break     default      func     interface    select
case      defer        go       map          struct
chan      else         goto     package      switch
const     fallthrough  if       range        type
continue  for          import   return       var
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;针对自己不太熟悉的关键字说明下虽然以后用着会熟悉但是提前了解不是坏事&quot;&gt;针对自己不太熟悉的关键字说明下，虽然以后用着会熟悉，但是提前了解不是坏事&lt;/h4&gt;
&lt;h3 id=&quot;break&quot;&gt;break:&lt;/h3&gt;
&lt;p&gt;跳出循环&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    //跳出循环
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(i)
        if i == 6 {
            break
        }
    }
}

---------------------------------
0
1
2
3
4
5
6

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;switch-case-default&quot;&gt;switch case default:&lt;/h3&gt;
&lt;p&gt;switch分支流程控制语句&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    //写法1：
    switch i := 6; i {
    case 1, 3, 5, 7, 9:
        fmt.Println(&quot;奇数5&quot;)
    case 2, 4, 6, 8, 10:
        fmt.Println(&quot;偶数&quot;)
    default:
        fmt.Println(&quot;other&quot;, i)
    }

    //写法2：
    finger := 2
    switch finger {
    case 1:
        fmt.Println(&quot;大拇指&quot;)
    case 2:
        fmt.Println(&quot;食指&quot;)
    case 3:
        fmt.Println(&quot;中指&quot;)
    case 4:
        fmt.Println(&quot;无名指&quot;)
    case 5:
        fmt.Println(&quot;小指&quot;)
    default:
        fmt.Println(&quot;无效的数字&quot;)
    }

    //写法3：
    age := 30
    switch {
    case age &amp;lt; 24:
        fmt.Println(&quot;学习阶段&quot;)
    case age &amp;gt;= 24 &amp;amp;&amp;amp; age &amp;lt; 60:
        fmt.Println(&quot;工作阶段&quot;)
    case age &amp;gt; 60:
        fmt.Println(&quot;退休阶段&quot;)
    default:
        fmt.Println(&quot;活着真好&quot;)
    }
}

---------------------------------
偶数
食指
工作阶段

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;func&quot;&gt;func:&lt;/h3&gt;
&lt;p&gt;函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1、带返回值的函数
func add(a, b int) int {
    return a + b
}

//2、多个返回值的函数
func vals() (int, int) {
    return 3, 7
}

//3、没返回值的函数
func query () {
    fmt.Println(&quot;query success.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;interface&quot;&gt;interface:&lt;/h3&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Dog interface {
    Category()
}

type Ha struct {
    Name string
}

func (h Ha) Category() {
    fmt.Println(&quot;狗子&quot;)
}

func main() {
    h := Ha{&quot;二哈&quot;}
    h.Category()
    test(h)
}

func test(a Dog) {
    fmt.Println(&quot;成功调用啦&quot;)
}

---------------------------------
狗子
成功调用啦

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select&quot;&gt;select:&lt;/h3&gt;
&lt;p&gt;A “select” statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a “switch” statement but with the cases all referring to communication operations.&lt;br /&gt;
一个select语句用来选择哪个case中的发送或接收操作可以被立即执行。它类似于switch语句，但是它的case涉及到channel有关的I/O操作。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//select基本用法
select {
case &amp;lt;- chan1:
// 如果chan1成功读到数据，则进行该case处理语句
case chan2 &amp;lt;- 1:
// 如果成功向chan2写入数据，则进行该case处理语句
default:
// 如果上面都没有成功，则进入default处理流程
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;defer&quot;&gt;defer:&lt;/h3&gt;
&lt;p&gt;A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.&lt;br /&gt;
一个defer语句在函数返回、函数结束或者对应的goroutine发生panic的时候defer就会执行。&lt;br /&gt;
在golang中，我们使用defer语句来进行一些错误处理和收尾工作，它的作用类似java里面finally关键字的作用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }
    defer dst.Close()

    // other codes
    return io.Copy(dst, src)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;列举2个简单demo:&lt;br /&gt;
demo1: 理解延迟&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    // demo1
    defer fmt.Println(&quot;hello&quot;)
    fmt.Println(&quot;world&quot;)
}

--------------------------------
world
hello

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;demo2: 理解defer、return、返回值的顺序&lt;br /&gt;
1、多个defer的执行顺序为“后进先出”；&lt;br /&gt;
2、defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    // demo2
    fmt.Println(&quot;c return:&quot;, *(c())) // 打印结果为 c return: 2
}

func c() *int {
    var i int
    defer func() {
        i++
        fmt.Println(&quot;c defer2:&quot;, i) // 打印结果为 c defer: 2
    }()
    defer func() {
        i++
        fmt.Println(&quot;c defer1:&quot;, i) // 打印结果为 c defer: 1
    }()
    return &amp;amp;i
}

---------------------------------
c defer1: 1
c defer2: 2
c return: 2

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;go&quot;&gt;go:&lt;/h3&gt;
&lt;p&gt;轻松开启高并发，一直都是golang语言引以为豪的功能点。golang通过goroutine实现高并发，而开启goroutine的钥匙正是go关键字。开启并发执行的语法格式是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    go testName()
    fmt.Println(&quot;main method&quot;)
    time.Sleep(time.Second)
}

func testName () {
    fmt.Println(&quot;test method&quot;)
}

---------------------------------
main method
test method

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;map&quot;&gt;map:&lt;/h3&gt;
&lt;p&gt;map是映射关系容器为map，其内部使用散列表（hash）实现，一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
    //1、声明map
    scoreMap := make(map[string]int, 8)
    scoreMap[&quot;张三&quot;] = 90
    scoreMap[&quot;小明&quot;] = 100
    fmt.Println(scoreMap)
    fmt.Println(scoreMap[&quot;小明&quot;])
    fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)

    //2、遍历map
    for k, v := range scoreMap {
        fmt.Printf(&quot;key[%s] - value[%d]\n&quot;, k, v)
    }

    //3、遍历map只要key或者value
    for k := range scoreMap {
        fmt.Printf(&quot;key[%s]\n&quot;, k)
    }

    for _, v := range scoreMap {
        fmt.Printf(&quot;value[%d]\n&quot;, v)
    }

    //4、判断某个key是否存在  特殊写法：value, ok := map[key]
    // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
    v, ok := scoreMap[&quot;张三&quot;]
    if ok {
        fmt.Println(v)
    } else {
        fmt.Println(&quot;查无此人&quot;)
    }

    //5、删除某个key
    //将小明:100从map中删除
    delete(scoreMap, &quot;小明&quot;)
    for k,v := range scoreMap{
        fmt.Printf(&quot;key[%s] - value[%d]\n&quot;, k, v)
    }
}

---------------------------------
map[小明:100 张三:90]
100
type of a:map[string]int

key[张三] - value[90]
key[小明] - value[100]

key[张三]
key[小明]
value[90]
value[100]

90

key[张三] - value[90]

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 11 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/Golang_study_01/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/Golang_study_01/</guid>
        
        <category>golang</category>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>被同事误删表找回丢失的数据</title>
        <description>&lt;h4 id=&quot;有些不靠谱的同事真的很误事运维了几年的系统从来没出过误删表数据的事件3月14日下午突然被同事误删了订单表全量数据查询表返回0-rows突然大脑一片空白心想完了完了最重要的表数据全部被清理了虽然有每日凌晨5点的全量备份但是截止下午的数据怎么找回从来没碰到过误删事件也从来没处理过数据恢复&quot;&gt;有些不靠谱的同事真的很误事，运维了几年的系统从来没出过误删表数据的事件，3月14日下午突然被同事误删了订单表全量数据，查询表返回0 rows，突然大脑一片空白，心想完了完了，最重要的表数据全部被清理了，虽然有每日凌晨5点的全量备份，但是截止下午的数据怎么找回？从来没碰到过误删事件，也从来没处理过数据恢复。。。&lt;/h4&gt;

&lt;h3 id=&quot;一先挽救每日备份的数据&quot;&gt;一、先挽救每日备份的数据&lt;/h3&gt;
&lt;p&gt;找到每日全量备份的数据，把订单表还原到测试库，然后单独把订单表重新备份，针对误删的表进行全量恢复
采用的工具是mydumper，非mysql官方的mydump
心想：好在有每日凌晨5点的全量备份，虽然在自己手里，从开发了每日全量备份脚本并配置定时任务每天执行，从来没派上用场，也希望不会派上用场，但是良好的备份意识还是挽救了90%的数据。
半小时左右，90%的数据恢复，然后把问题上报。&lt;/p&gt;

&lt;h3 id=&quot;二没处理过误删也没恢复数据经验保留现场上报事故&quot;&gt;二、没处理过误删也没恢复数据经验，保留现场，上报事故&lt;/h3&gt;
&lt;p&gt;把90%数据恢复后，赶快写了一封邮件，把事故上报，说明丢失的数据范围、后果，恢复了多少等等，让上级是否请专业的数据恢复，结果上级喊我过去是否可以把剩下的当日备份后的数据找回来，我想了一想，说可以找，只是我没这方面的经验，可能效率和时间上不会很快，这里上级的算盘打得太精了，不愿意请恢复数据的人才来临时救火。。。&lt;/p&gt;

&lt;h3 id=&quot;三尝试解析binlog&quot;&gt;三、尝试解析binlog&lt;/h3&gt;
&lt;p&gt;以自己对mysql的理解，找到当天的binlog，备份下来，查找资料解析binlog，因为没经验，几小时后才解决问题，把binlog由二进制解析成可读的文本，但是查看解析后的文件，仍然可读性较差，很多字段还是@，中间还有很多集群同步的信息干扰等等，中间的苦难不描述那么多了，反正是拿到了10G的解析后的数据。。。&lt;/p&gt;

&lt;h3 id=&quot;四缩小范围&quot;&gt;四、缩小范围&lt;/h3&gt;
&lt;p&gt;缩小误删事件的范围，减少日志文件的大小，然后把10G的文本降低到6G，仍然还是没法看的，中间经过好多天在github、各大运维论坛查找mysql恢复工具，python2、3的工具找了不少，都是无能为了，几乎没啥作用… 这些脚本都有个前提，要求mysql开启了一些参数，比如row模式，检测对比，自己手中的生产库有些参数不满足，没法直接用，改造脚本来不及了，只好换个思路，用土法子，把解析的binlog数据提取出来&lt;/p&gt;

&lt;h3 id=&quot;五写脚本提取缩小范围后的binlog日志&quot;&gt;五、写脚本提取缩小范围后的binlog日志&lt;/h3&gt;
&lt;p&gt;找到insert语句的规律，自己编写shell脚本提取数据，把凌晨5点截止到下午误删时间中间的数据提取出来，转化成insert sql语句
不过时间已经过去一周了，虽然过程很乱，但是自己的头脑时清晰的，没有可用的现成的数据恢复工具，自己造工具。&lt;/p&gt;

&lt;h3 id=&quot;六结果&quot;&gt;六、结果&lt;/h3&gt;
&lt;p&gt;中间没有备份的数据基本上恢复，几百条数据全部提取成功，然后执行入库，完美解决。。。&lt;/p&gt;

&lt;h2 id=&quot;ps整个过程有惊无险总结几点&quot;&gt;PS：整个过程有惊无险，总结几点：&lt;/h2&gt;
&lt;p&gt;1、要熟悉mysql的机制，了解当前数据存放在哪个二进制文件&lt;br /&gt;
2、最重要的前提，有日备份，没有这点，我也是无能为力解决这次问题&lt;br /&gt;
3、找一些现成的工具和测试工具浪费了我大量的时间，有得必有失，不可能别人或者某个大厂的工具正好满足你，结果还是需要自己解析binlog并提取字段参数&lt;br /&gt;
4、庆幸的是，时间上没给我太大的压力，一周才整理完几个G的文件解析并拿到合适的数据&lt;br /&gt;
5、冷静分析问题，虽然没经历过这些事故，但是以自己的经验和冷静，最终完美找回99.9%,为啥还有0.1%,误删表的时候，数据库自动重启了，因为百万级别的表被删除已经引起服务器IO和mysql的IO异常了，mysql自动重启，重启期间的数据在业务日志中报错，因为经历有限，一周后没法再回头整理这些入库异常的信息。&lt;br /&gt;
6、最后查找事故的主角，谁删了这张表，查找了mysql日志，没记录到IP，不过就算记录到IP也没辙，因为我们有中间件读写分离，记录的也是中间件IP&lt;br /&gt;
7、事后反省，猪队友太多了，可能有人问不要给猪队友这种权限的账号，其实我们项目管理还比较正规的，我们有运维账号、业务账号、查询账号，正是运维的账号把表数据清理，空表留着。并不是drop表，运维账号有修改数据权限，没drop权限。&lt;br /&gt;
整个记录比较乱，只是不吐不快。。。&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/mysql_data_restore/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/mysql_data_restore/</guid>
        
        <category>mysql</category>
        
        <category>误删</category>
        
        <category>binlog</category>
        
        
      </item>
    
      <item>
        <title>JDK1.8.0.161版本bug定位</title>
        <description>&lt;h4 id=&quot;好好运行的系统突然故障无意间根据错误信息查找竟然是jdk的bug描述下曲折的定位过程&quot;&gt;好好运行的系统，突然故障，无意间根据错误信息查找，竟然是jdk的bug，描述下曲折的定位过程。&lt;/h4&gt;

&lt;h3 id=&quot;一错误日志&quot;&gt;一、错误日志&lt;/h3&gt;
&lt;p&gt;有个老系统有使用到soap接口，采用CXF结合接口文件wsdl自动生成的接口开发的，突然在3月2日（后续日志定位才发现真正故障的时间）无法正常工作，但是实际发现时间已经到了3月6日了，直接查看日志文件，报错“组装saop报文头异常:Entity References are not allowed in SOAP documents”，想到看看是不是代码做了什么改动，进svn版本管理工具对比，没有改动，最近一次部署是在3月5日上午，3月2日周六突然就故障了，属于突发性异常，感觉可以排除自身的问题，然后去咨询服务端系统，对方说也没有任何改动，现在才接手，不可能进行新的开发。但是接口一直在日志中打印错误，对比svn提交记录，发现确实没人改动代码，难道是对方动了代码？抱着这种心态总觉得是服务端异常了。
&lt;img src=&quot;/images/posts/jdkbug/error.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二检查代码和修改记录&quot;&gt;二、检查代码和修改记录&lt;/h3&gt;
&lt;p&gt;有了这个排除自己代码改动造成异常的前提后，始终觉得是服务端异常了，然后通过抓包对比正常接口、异常接口，SoapUI发送，重现错误返回值等一系列对比，3月6、7日没有任何结果，唯一发现就是报错的接口没有soap请求没有head信息，只有UTF-8的字符集和body，这种结构就有些奇怪了，难道是鉴权账号被锁？继续用soapUI测试这个账号，其他接口跑起来正常，修改了一条数据返回是success，更加郁闷了，怎么可能head平白无故丢失呢？&lt;/p&gt;

&lt;h3 id=&quot;三继续啃问题&quot;&gt;三、继续啃问题&lt;/h3&gt;
&lt;p&gt;继续啃这个问题，因为有数据堵住了，慢慢积压越来越多，这样下去迟早会造成更大的失误。问题还是要继续解决，只好重新打包个测试包，去测试环境对接soap服务端，下个订单，查看日志和抓包，查看接口推送的请求，测试环境验证正常，说明代码OK，抓包查看xml报文，head和body都在。6、7日的对比把报错的信息复制到百度看看有没查询到类似的案例，结果都是乱七八糟的一堆东西，没什么价值。&lt;/p&gt;

&lt;h3 id=&quot;四抛弃baidu用google&quot;&gt;四、抛弃baidu用google&lt;/h3&gt;
&lt;p&gt;6、7号1天半没找到问题，但是又不可以继续拖了，试试google呗，一下眼前一亮，第一条查询就是openJDK的bug库，一直没怀疑jdk的bug，始终认为它是正常的，赶快找到jdk bug库，把关键字放进去一查询，查到结果有个bug单，心里一喜，终于找到问题原因了。啃了2天半了，终于找到问题的原因了：
&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8196491&quot;&gt;OpenJDK bug库&lt;/a&gt; | 
&lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8196491&quot;&gt;OracleJDK bug库&lt;/a&gt; | 
&lt;a href=&quot;https://stackoverflow.com/questions/48603942/latest-open-jdk-8-jaxb-library-fails-to-unmarshal-objects-with-properties-that-c&quot;&gt;stackoverflow bug讨论&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;五垃圾百度google有用&quot;&gt;五、垃圾百度，google有用&lt;/h3&gt;
&lt;p&gt;这里吐槽下，垃圾百度，以前还可以筛选一些有用的信息，这次白白浪费2天的时间，没有价值的信息一堆，就放弃网上找案例了。
google里面可以找到stackoverflow和openjdk的链接，已经确认jdk1.8.0版本的bug，2018年01月份暴露该bug，2018年04月份修复，修复版本是1.8.0.192。&lt;/p&gt;

&lt;h3 id=&quot;六下载新update版本jdk&quot;&gt;六、下载新update版本jdk&lt;/h3&gt;
&lt;p&gt;立马下载最新202 update版本，部署环境，重新，偶然没有出现相同的错了，然后一看时间，已经是3月8日21:30了，继续观察下，确认正常，问题得以修复。估算堵住的数据，预计还需要36小时才可以处理完，周末时间刚好。这下周末可以轻松下，不用跑来继续啃问题了。&lt;/p&gt;

&lt;h2 id=&quot;附上错误信息截图&quot;&gt;附上错误信息截图：&lt;/h2&gt;
&lt;h4 id=&quot;openjdk的版本错误信息描述&quot;&gt;OpenJDK的版本错误信息描述：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/jdkbug/jdkbug.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;openjdk的错误样例&quot;&gt;OpenJDK的错误样例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/jdkbug/bug2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;业务日志中的错误信息&quot;&gt;业务日志中的错误信息：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/jdkbug/buglog.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;业务所在服务器的jdk版本和安装时间&quot;&gt;业务所在服务器的JDK版本和安装时间：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/jdkbug/log.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;ps有一点是这个jdk跑了这个出bug的业务差不多1年了为啥这1年不出问题呢怀疑是header里的鉴权session字符串开始用完纯字母类型的出现带特殊字符的了从开始出现特殊字符就触发这个bug&quot;&gt;PS：有一点是这个jdk跑了这个出bug的业务差不多1年了，为啥这1年不出问题呢？怀疑是header里的鉴权session字符串开始用完纯字母类型的，出现带特殊字符的了，从开始出现特殊字符就触发这个bug&lt;/h2&gt;
</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/jdkbug/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/jdkbug/</guid>
        
        <category>JDK的bug</category>
        
        
      </item>
    
      <item>
        <title>Cygwin安装</title>
        <description>&lt;h4 id=&quot;cygwin是windows平台上运行的unix模拟环境它对于学习unixlinux操作环境或者从unix到windows的应用程序移植或者进行某些特殊的开发工作尤其是使用gnu工具集在windows上进行嵌入式系统开发非常有用&quot;&gt;cygwin是windows平台上运行的unix模拟环境，它对于学习unix/linux操作环境，或者从unix到windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用gnu工具集在windows上进行嵌入式系统开发，非常有用。&lt;/h4&gt;

&lt;h4 id=&quot;cygwin相对安装虚拟机vps是轻量级的因此在条件不足情况下练习学习shell等都是很好的选择&quot;&gt;cygwin相对安装虚拟机、vps是轻量级的，因此在条件不足情况下，练习、学习shell等都是很好的选择。&lt;/h4&gt;

&lt;h3 id=&quot;一cygwin的安装&quot;&gt;一、Cygwin的安装&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载Cygwin，这个可以到这里下载 ，至于使用32位的还是64位的版本可以根据自己的系统而定，打开下载好的setup-x86.exe（以64bit-windws系统为例） 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我这里选择的是2.876（64位）版本
&lt;img src=&quot;/images/posts/cygwin/install1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第一个选项是在线安装，第二个选项是只下载不安装（然后手动安装），第三个指你已经下载了安装包，通过已经下载的本地安装包安装，若是第一次安装，选中第一个即可（默认），【下一步】
&lt;img src=&quot;/images/posts/cygwin/install2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定unix系统的根目录，以及限定那些用户可以访问这个目录。安装目录别为中文名,以免出错,接入网站如果不行,提示错误,那就重新来换一个接入网站，建议这个路径要指定在空间比较大的硬盘，在后面的开发中，这个目录是工作目录，随着积累会越来越大
&lt;img src=&quot;/images/posts/cygwin/install3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定包的下载目录，安装完成以后可删除，下面的单选框默认即可，【下一步】
&lt;img src=&quot;/images/posts/cygwin/install4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择连接方式，如果用的是外网，选择第一个（默认）即可，如果使用的是公司网或者其他需要代理的内网，记得使用相应的代理，一般如果默认浏览器有设代理，选择第二个就好，如果默认浏览器没有设代理，则使用第三项自己配置代理，【下一步】
&lt;img src=&quot;/images/posts/cygwin/install5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择一个镜像站点，任选一个即可，按Ctrl键可选中多个。这里需要注意一下，对于国内的用户，强烈建议使用国内的镜像，这样可以在后面的下载过程中有更快的速度，比如我这里使用的是http://mirrors.163.com/cygwin/，【下一步】
&lt;img src=&quot;/images/posts/cygwin/install6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;这一步很关键，选择要下载和安装的包，根据你的需要选择包，选的包越多所需的下载时间越长，单击【View】可以在分类、全部、已选之间循环切换，点击每一类前面的加号可以展开，要选中每一个包，只需单击每一行前边像循环的那个图标，会在版本号和Skip之间切换，选一个最新的版本号即可，下边的那个复选框默认即可。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了后面的操作，我们有必要在这里选择一些必要的包进行安装：
(1) curl
(2) git* (git, git-gui, gitk)；
(3) libreadline7, libiconv2
(4) vim, ctags
(5) python
(6) lynx
(7) wget, tar, gawk, bzip2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;当然其中有一些是已经就默认勾选的，在选择的时候只要在search里面输入对应名称，它就会自动过滤出你要安装的包了，然后将循环Skip切换成你需要安装的版本就好了，一定要记得在搜索的时候不需要按Enter, 不然就直接跳到下一步了。
&lt;img src=&quot;/images/posts/cygwin/install7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;选好后【下一步】下图，会显示你选择的安装包：
&lt;img src=&quot;/images/posts/cygwin/install8.jpg&quot; alt=&quot;&quot; /&gt;
单击下一步开始安装，最后会让你让你选择是否生成快捷方式，然后OK了！
以后要安装新的安装包，或是更新，还是通过这个过程，运行setup.exe选择安装包即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二cygwin的配置&quot;&gt;二、Cygwin的配置&lt;/h3&gt;
&lt;p&gt;打开Cygwin终端,右击打开 Options…选项
Text可以设置字体的一些属性,如大小、编码,Locale 选择C, Character set 选择 UTF-8,可以避免中文显示乱码&lt;/p&gt;

&lt;h3 id=&quot;三安装apt-cyg&quot;&gt;三、安装apt-cyg&lt;/h3&gt;
&lt;p&gt;这时就可以打开Cygwin64 Terminal，开始像正常linux终端一样在windows下工作了，但是现在还是比较粗糙，缺少很多我们必要的比如一些依赖库和命令，而且我们比较熟悉的apt-get也没有，在Cygwin中，我们使用apt-cyg来下载和管理安装包，下面我们来介绍怎么安装它：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/transcode-open/apt-cyg.git
cd apt-cyg
install apt-cyg /bin

#检测是否安装成功
apt-cyg --help

#出现如下帮助信息，表示安装成功
$ apt-cyg --help
NAME
  apt-cyg - package manager utility

SYNOPSIS
  apt-cyg [operation] [options] [targets]

DESCRIPTION
  apt-cyg is a package management utility that tracks installed packages on a
  Cygwin system. Invoking apt-cyg involves specifying an operation with any
  potential options and targets to operate on. A target is usually a package
  name, file name, URL, or a search string. Targets can be provided as command
  line arguments.
  ......
  ......
  ......

#出现其他提示，可能是安装出现故障了，请删除apt-cyg包后重新下载再安装配置。  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ps：win10可能会在执行install出现个错误提示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/apt-cyg:行25: $'\r': 未找到命令
/usr/bin/apt-cyg:行121: 未预期的符号 `$'{\r'' 附近有语法错误
'usr/bin/apt-cyg:行121: `function wget {
由于windows上的换行符和linux上不同，因此notepad++打开apt-cyg文件，替换所有的\r为空，保存即可使用apt-cyg了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;四安装其他组件&quot;&gt;四、安装其他组件&lt;/h3&gt;
&lt;p&gt;就可以随便安装相应的软件了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-cyg install man cygwin-doc 
apt-cyg install vim screen wget subversion openssh pwgen gzip bzip2 curl rsync bash-completion lftp nc tree p7zip connect-proxy util-linux bind-utils inetutils
#有了apt-cyg这个神器后，后续安装就可以类似yum、apt-get那么方便了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 12 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/09/cygwin_install/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/09/cygwin_install/</guid>
        
        <category>cygwin</category>
        
        
      </item>
    
      <item>
        <title>oracle知识梳理-执行计划分析</title>
        <description>&lt;h2 id=&quot;分析某条sql的性能问题通常我们要先看sql的执行计划看看sql的每一步执行是否存在问题常用的两种方法查看sql执行计划&quot;&gt;分析某条SQL的性能问题，通常我们要先看SQL的执行计划，看看SQL的每一步执行是否存在问题。常用的两种方法查看SQL执行计划。&lt;/h2&gt;
&lt;h4 id=&quot;方法一autotrace生成执行计划&quot;&gt;方法一：autotrace生成执行计划&lt;/h4&gt;

&lt;h4 id=&quot;这种方式执行方便但是当遇到执行时间长的sql就变得不太现实它是先产生结果再生成执行计划的关于autotrace几个常用选项的说明&quot;&gt;这种方式执行方便，但是当遇到执行时间长的SQL就变得不太现实，它是先产生结果再生成执行计划的。关于Autotrace几个常用选项的说明：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SET  AUTOTRACE  OFF ---------------- 不生成AUTOTRACE 报告，这是缺省模式
SET  AUTOTRACE  ON  EXPLAIN --------- AUTOTRACE只显示优化器执行路径报告
SET  AUTOTRACE  ON  STATISTICS ------ 只显示执行统计信息
SET  AUTOTRACE  ON ----------------- 包含执行计划和统计信息
SET  AUTOTRACE  TRACEONLY -----------同set autotrace on，但是不显示查询输出
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;步骤-1-sqlplus登录数据库&quot;&gt;步骤 1 sqlplus登录数据库&lt;/h3&gt;
&lt;h3 id=&quot;步骤-2-打开autotrace&quot;&gt;步骤 2 打开autotrace&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SQL&amp;gt; set autotrace on explain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-3-输入要查看的sql&quot;&gt;步骤 3 输入要查看的SQL&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SQL&amp;gt; select po.charge, po.new_charge, po.avg_charge
         from lbi_ls_basic.t_l_acct_sum_po_sum_d  po,
             lbi_dim_basic.t_d_dyn_pkgname     pkg,
             lbi_dim_basic.t_d_dyn_tenant_def     def
 where po.subcosid = pkg.productkey(+)
         and po.tenantid = def.tenantid(+); 
返回执行计划结果
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-4-关闭autotrace&quot;&gt;步骤 4 关闭autotrace&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SQL&amp;gt; set autotrace off
----结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;方法二explain-plan-for-生成执行计划&quot;&gt;方法二、explain plan for 生成执行计划&lt;/h4&gt;

&lt;h4 id=&quot;这种方式是直接产生执行计划不会产生sql结果&quot;&gt;这种方式是直接产生执行计划，不会产生SQL结果。&lt;/h4&gt;

&lt;h3 id=&quot;步骤1-sqlplus登录数据库&quot;&gt;步骤1 sqlplus登录数据库&lt;/h3&gt;
&lt;h3 id=&quot;步骤2-执行explain-plan-for语句&quot;&gt;步骤2 执行explain plan for语句&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SQL&amp;gt; explain plan for 
select po.charge, po.new_charge,po.avg_charge
           from lbi_ls_basic.t_l_acct_sum_po_sum_d   po,
                lbi_dim_basic.t_d_dyn_pkgname       pkg,
                lbi_dim_basic.t_d_dyn_tenant_def     def
       where po.subcosid = pkg.productkey(+) and po.tenantid = def.tenantid(+)
       ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤3-查询执行计划&quot;&gt;步骤3 查询执行计划&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SQL&amp;gt; select * from table(dbms_xplan.display);
返回结果：略
----结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;以上都是不借助图形化的工具借助图形化的工具后方便很多比如plsql-developer强大的不行或者toad也行&quot;&gt;以上都是不借助图形化的工具，借助图形化的工具后方便很多，比如:PL/SQL Developer强大的不行，或者Toad也行。&lt;/h2&gt;
</description>
        <pubDate>Sun, 27 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/oracle-excuteplan/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/oracle-excuteplan/</guid>
        
        <category>oracle</category>
        
        
      </item>
    
      <item>
        <title>oracle知识梳理-awr\ash\addm日志开启并提取</title>
        <description>&lt;h2 id=&quot;之前工作经常搜集awr日志但是因工作环境的调整6年下来的笔记都无法带出来只能回忆一些和找一些网上的信息整理了&quot;&gt;之前工作经常搜集AWR日志，但是因工作环境的调整，6年下来的笔记都无法带出来，只能回忆一些和找一些网上的信息整理了。&lt;/h2&gt;

&lt;h4 id=&quot;常规的性能分析awr足够了但是深层次的问题需要更多的日志下面整理下awrashaddm日志的手工提取方式&quot;&gt;常规的性能分析，awr足够了，但是深层次的问题，需要更多的日志，下面整理下awr、ash、addm日志的手工提取方式&lt;/h4&gt;

&lt;h2 id=&quot;一awr报告开启和提取操作步骤&quot;&gt;一、awr报告开启和提取操作步骤:&lt;/h2&gt;

&lt;h4 id=&quot;前提条件数据库为oracle-10g以上版本&quot;&gt;前提条件数据库为Oracle 10g以上版本。&lt;/h4&gt;

&lt;h4 id=&quot;背景信息&quot;&gt;背景信息&lt;/h4&gt;

&lt;h4 id=&quot;oracle默认快照1小时生成一次保持7天可以根据需要调整快照生成的频率保持时长如果要手工生成快照则用&quot;&gt;Oracle默认快照1小时生成一次、保持7天，可以根据需要调整快照生成的频率、保持时长。如果要手工生成快照，则用&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~&amp;gt; sqlplus / as sysdba;登录数据库执行命令：
SQL&amp;gt; exec dbms_workload_repository.create_snapshot();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-1-以oracle用户登录操作系统&quot;&gt;步骤 1 以oracle用户登录操作系统。&lt;/h3&gt;
&lt;h3 id=&quot;步骤-2-登录数据库&quot;&gt;步骤 2 登录数据库。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~&amp;gt; sqlplus / as sysdba;
登录成功后，返回信息如下：
SQL*Plus: Release 11.1.0.7.0 - Production on Mon Jul 22 09:52:46 2013
 
Copyright (c) 1982, 2008, Oracle.  All rights reserved.
 
Connected to:
Oracle Database 11g Enterprise Edition Release 11.1.0.7.0 - 64bit Production
With the Partitioning, Oracle Label Security, OLAP, Data Mining,
Oracle Database Vault and Real Application Testing options
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-3-生成awr报表&quot;&gt;步骤 3 生成AWR报表。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 开始收集AWR报表
SQL&amp;gt; @?/rdbms/admin/awrrpt.sql;
说明：
对某些系统，@特殊字符前面可能需要转义字符\，才能运行该命令。请运行命令：SQL&amp;gt; \@?/rdbms/admin/awrrpt.sql;
返回信息显示如下：
Current Instance 
~~~~~~~~~~~~~~~~
   DB Id    DB Name      Inst Num Instance
----------- ------------ -------- ------------
 4188289306 ORA11G              1 ora11g
 
Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
Would you like an HTML report, or a plain text report?
Enter 'html' for an HTML report, or 'text' for plain text
Defaults to 'html'
Enter value for report_type:

2. 输入报表的格式，有HTML格式、TEXT格式，默认HTML格式。
例如输入格式为html，返回信息如下：
Type Specified:  html
 
Instances in this Workload Repository schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 DB Id     Inst Num DB Name      Instance     Host
------------ -------- ------------ ------------ ------------
* 4188289306        1 ORA11G       ora11g       linux_lbi_02
 
Using 4188289306 for database Id
Using          1 for instance number
 
Specify the number of days of snapshots to choose from
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Entering the number of days (n) will result in the most recent
(n) days of snapshots being listed.  Pressing &amp;lt;return&amp;gt; without
specifying a number lists all completed snapshots.
 
Enter value for num_days:1

3. 输入一个天数，Oracle会列出指定天数的所有快照信息。
例如输入一个天数为1，返回信息如下：
Listing the last day's Completed Snapshots
                       Snap
Instance     DB Name        Snap Id    Snap Started    Level
------------ ------------ --------- ------------------ -----
ora11g       ORA11G            3166 22 Jul 2013 00:00      1
                               3167 22 Jul 2013 01:00      1
                               3168 22 Jul 2013 02:00      1
                               3169 22 Jul 2013 03:00      1
                               3170 22 Jul 2013 04:00      1
                               3171 22 Jul 2013 05:00      1
                               3172 22 Jul 2013 06:00      1
                               3173 22 Jul 2013 07:00      1
                               3174 22 Jul 2013 08:00      1
                               3175 22 Jul 2013 09:00      1
Specify the Begin and End Snapshot Ids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Enter value for begin_snap:

4. 输入起始snap Id和结束snap Id，收集两个时刻间段的数据库性能数据。
起始snap Id和结束snap Id这两个时间段之间，不能关闭或启动数据库，否则会报错。
注意：
例如输入起始snap Id为3166，结束snap Id为3168，返回信息如下：
Specify the Begin and End Snapshot Ids 
Enter value for begin_snap: 3166
Begin Snapshot Id specified: 3166 
Enter value for end_snap: 3168
End   Snapshot Id specified: 3168 
Specify the Report Name
~~~~~~~~~~~~~~~~~~~~~~~
The default report file name is awrrpt_1_3166_3168.html.  To use this name,
press &amp;lt;return&amp;gt; to continue, otherwise enter an alternative.
Enter value for report_name:

5. 输入报表名
默认以snap Id命名，可以不输入。
如下所示为生成的AWR报表样例：
Report written to awrrpt_1_3166_3168.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-4-如果没指定目录和文件名生成的awr报表在当前目录执行如下命令查看&quot;&gt;步骤 4 如果没指定目录和文件名，生成的AWR报表在当前目录，执行如下命令查看。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 回到当前目录。
SQL&amp;gt; host;

2. 查看报表。
~&amp;gt; ls
返回信息显示如下：
awrrpt_1_3166_3168.html
----结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;二ash报告开启和提取操作步骤&quot;&gt;二、ash报告开启和提取操作步骤:&lt;/h2&gt;
&lt;h4 id=&quot;收集活动会话的历史信息短暂的性能问题比如只是持续几分钟的性能问题特定时段的数据库运行的性能状态信息以及针对特定的模块sql_idsession_idservice等来收集的性能状态信息&quot;&gt;收集活动会话的历史信息、短暂的性能问题（比如只是持续几分钟的性能问题）、特定时段的数据库运行的性能状态信息，以及针对特定的模块、SQL_ID、SESSION_ID、service等来收集的性能状态信息。&lt;/h4&gt;
&lt;h4 id=&quot;背景信息-1&quot;&gt;背景信息&lt;/h4&gt;
&lt;h4 id=&quot;ash每秒钟收集一次当前处于非空闲等待事件的活动状态的session的信息不收集空闲的会话&quot;&gt;ASH每秒钟收集一次当前处于非空闲等待事件的、活动状态的session的信息，不收集空闲的会话。&lt;/h4&gt;

&lt;h3 id=&quot;步骤-1-以oracle用户登录操作系统-1&quot;&gt;步骤 1 以Oracle用户登录操作系统。&lt;/h3&gt;
&lt;h3 id=&quot;步骤-2-登录数据库-1&quot;&gt;步骤 2 登录数据库。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:~&amp;gt; sqlplus / as sysdba; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-3-生成ash报表&quot;&gt;步骤 3 生成ASH报表&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 开始收集ASH报表。
SQL&amp;gt; @?/rdbms/admin/ashrpt.sql;
对某些系统，@特殊字符前面可能需要转义字符\，才能运行该命令。请运行命令：SQL&amp;gt; \@?/rdbms/admin/awrrpt.sql;
返回信息显示如下：
SQL&amp;gt; @?/rdbms/admin/ashrpt.sql;
Current Instance
~~~~~~~~~~~~~~~~
   DB Id    DB Name      Inst Num Instance
----------- ------------ -------- ------------
 4188289306 ORA11G              1 ora11g 
Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
Enter 'html' for an HTML report, or 'text' for plain text
Defaults to 'html'
Enter value for report_type:

2. 输入报表的格式，有HTML格式、TEXT格式，默认HTML格式。
例如输入格式为html，返回信息如下：
Type Specified:  html
Instances in this Workload Repository schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   DB Id     Inst Num DB Name      Instance     Host
------------ -------- ------------ ------------ ------------
* 4188289306        1 ORA11G       ora11g       linux_lbi_02
Defaults to current database
Using database id: 4188289306
Defaults to current instance
Using instance number: 1
ASH Samples in this Workload Repository schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Oldest ASH sample available:  22-Jul-13 08:00:43   [  11641 mins in the past]
Latest ASH sample available:  30-Jul-13 10:00:28   [      1 mins in the past]
Specify the timeframe to generate the ASH report
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Enter begin time for report:
--    Valid input formats:
--      To specify absolute begin time:
--        [MM/DD[/YY]] HH24:MI[:SS]
--        Examples: 02/23/03 14:30:15
--                  02/23 14:30:15
--                  14:30:15
--                  14:30
--      To specify relative begin time: (start with '-' sign)
--        -[HH24:]MI
--        Examples: -1:15  (SYSDATE - 1 Hr 15 Mins)
--                  -25    (SYSDATE - 25 Mins)
Defaults to -15 mins
Enter value for begin_time: 07/29/2013 19:00:00

3. 按照提示的有效格式输入收集信息的开始时间。
有效格式有：
a、具体的日期和时间，如02/23/03 14:30:15。
b、当天的某个时间，如14:30:15或14:30。
c、相对时间，如距当前时间1个半小时输入-1:30，距当前时间15分钟输入-15。
例如输入时间07/29/2013 19:00:00，返回信息如下：
Report begin time specified: 07/29/2013 19:00:00
Enter duration in minutes starting from begin time:
Defaults to SYSDATE - begin_time
Press Enter to analyze till current time
Enter value for duration: 20

4. 输入需要收集信息的时间跨度，单位为分钟。
如上所示，收集信息的时间跨度为20分钟。
返回信息如下：
Report duration specified:   20
Using 29-Jul-13 19:00:00 as report begin time
Using 29-Jul-13 19:20:00 as report end time
……………….
Specify the Report Name
~~~~~~~~~~~~~~~~~~~~~~~
The default report file name is ashrpt_1_0729_1920.html.  To use this name,
press &amp;lt;return&amp;gt; to continue, otherwise enter an alternative.
Enter value for report_name:

5. 输入报表名，默认以“ashrpt_instance_Id_日期_时间”命名，可以不输入。
如下所示为生成的ASH报表样例：
Report written to ashrpt_1_0729_1920.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-4-如果没指定目录和文件名生成的ash报表在当前目录执行如下命令查看&quot;&gt;步骤 4 如果没指定目录和文件名，生成的ASH报表在当前目录，执行如下命令查看。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 回到当前目录。
SQL&amp;gt; host;

2. 查看报表。
:~&amp;gt; ls
返回信息显示如下：
ashrpt_1_0729_1920.html
----结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;三addm日志开启和提取操作步骤&quot;&gt;三、ADDM日志开启和提取操作步骤:&lt;/h2&gt;
&lt;h4 id=&quot;收集定期内的数据库状态潜在的数据库性能瓶颈以及内建专家系统给出的oracle性能调优方法和数据统计分析&quot;&gt;收集定期内的数据库状态、潜在的数据库性能瓶颈，以及内建专家系统给出的Oracle性能调优方法和数据统计分析。&lt;/h4&gt;

&lt;h3 id=&quot;步骤-1-以oracle用户登录操作系统-2&quot;&gt;步骤 1 以oracle用户登录操作系统。&lt;/h3&gt;
&lt;h3 id=&quot;步骤-2-登录数据库-2&quot;&gt;步骤 2 登录数据库。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:~&amp;gt; sqlplus / as sysdba; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-3-生成addm报表&quot;&gt;步骤 3 生成addm报表。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 开始收集addm报表。
SQL&amp;gt; @?/rdbms/admin/addmrpt; 
对某些系统，@特殊字符前面可能需要转义字符\，才能运行该命令。请运行命令：SQL&amp;gt; \@?/rdbms/admin/awrrpt.sql;
返回信息显示如下：
Current Instance 
~~~~~~~~~~~~~~~~ 
 
   DB Id    DB Name      Inst Num Instance 
----------- ------------ -------- ------------ 
 1049289546 HUNAO               1 hunao 
......  
Listing the last 3 days of Completed Snapshots 
                                                        Snap 
Instance     DB Name        Snap Id    Snap Started    Level 
------------ ------------ --------- ------------------ ----- 
hunao        HUNAO             3311 28 Jul 2013 08:00      1 
                               ...... 
                               3315 28 Jul 2013 12:00      1 
                               3316 28 Jul 2013 13:00      1

2. 根据Oracle列出的snap Id提示，输入起始snap Id和结束snap Id，收集两个时段的数据库性能数据。
例如输入起始snap Id为3311，结束snap Id为3316，返回信息如下：
Specify the Begin and End Snapshot Ids 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Enter value for begin_snap: 3311 --指定开始snap id 
Begin Snapshot Id specified: 3316
 
Enter value for end_snap: 3311 --指定结束snap id 
End   Snapshot Id specified: 3316
 
Specify the Report Name 
...... 
Enter value for report_name:

3. 输入报表名，默认以snap Id命名，可以不输入。
如下所示为生成的ADDM报表样例：
Report written to addmrpt_1_3311_3316.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;步骤-4-如果没指定目录和文件名生成的addm报表在当前目录执行如下命令查看&quot;&gt;步骤 4 如果没指定目录和文件名，生成的ADDM报表在当前目录，执行如下命令查看。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 回到当前目录。
SQL&amp;gt; host;

2. 查看报表。
:~&amp;gt; ls
返回信息显示如下：
addmrpt_1_3311_3316.txt
----结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 27 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/oracle-db/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/oracle-db/</guid>
        
        <category>oracle</category>
        
        
      </item>
    
      <item>
        <title>java小日常记录-不定期更新</title>
        <description>&lt;h3 id=&quot;1web项目远程调测---仅用于测试环境或者上线前的调测&quot;&gt;1、web项目远程调测 - 仅用于测试环境或者上线前的调测&lt;/h3&gt;

&lt;h4 id=&quot;注意仅限测试环境或者上线前的调测如果用于生产环境你的开发工具再debug模式起着的话会拦截所有的请求&quot;&gt;注意：仅限测试环境或者上线前的调测，如果用于生产环境，你的开发工具再debug模式起着的话，会拦截所有的请求。&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# linux增加以下这段就可以远程连接服务器的5888端口了
CATALINA_OPTS=&quot;-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5888&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;添加了debug端口以后好像会出现shutdownsh-无法关闭tomcat需要手动kill&quot;&gt;添加了debug端口以后好像会出现./shutdown.sh 无法关闭tomcat，需要手动kill&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Windows下面修改catalina.bat，增加：
SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5888
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后配置你的eclispe启动remote：新建remote java Application
&lt;img src=&quot;/images/posts/debug/add-remote.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置host和port：
&lt;img src=&quot;/images/posts/debug/config.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后就可以调测定位问题。&lt;/p&gt;

&lt;h3 id=&quot;2生产环境的数据问题如何在本地开发环境重现&quot;&gt;2、生产环境的数据问题如何在本地开发环境重现？&lt;/h3&gt;

&lt;h4 id=&quot;这个问题碰不到还好碰到就头疼了我个人是把依赖的几个工程转成osgi的模式然后测试代码替换到spring的服务抓到生产的入参然后在测试代码中跟踪逻辑走向&quot;&gt;这个问题碰不到还好，碰到就头疼了，我个人是把依赖的几个工程转成osgi的模式，然后测试代码，替换到spring的服务，抓到生产的入参，然后在测试代码中跟踪逻辑走向。&lt;/h4&gt;

&lt;h3 id=&quot;3base64奇葩问题&quot;&gt;3、base64奇葩问题&lt;/h3&gt;

&lt;h4 id=&quot;周五2017年6月10日晚碰到个诡异问题&quot;&gt;周五（2017年6月10日晚）碰到个诡异问题：&lt;/h4&gt;

&lt;h4 id=&quot;用maven引入commons-codec-110的包使用base64加密结果怎么都不对一直提示方法找不到如下面的报错&quot;&gt;用maven引入commons-codec-1.10的包，使用base64加密，结果怎么都不对，一直提示方法找不到，如下面的报错&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Java.lang.NoSuchMethodError: org.apache.commons.codec.binary.Base64.decodeBase64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;后来找了下发现qq的第三方登录sdk包重写了apache的base64而且包名都一样导致找不到对应的方法&quot;&gt;后来找了下，发现QQ的第三方登录SDK包重写了apache的base64，而且包名都一样，导致找不到对应的方法，&lt;/h4&gt;

&lt;h4 id=&quot;经打开两个包查看验证确实如此给自己做个记录以免再入坑&quot;&gt;经打开两个包查看，验证确实如此，给自己做个记录，以免再入坑：&lt;/h4&gt;

&lt;h4 id=&quot;qq的sdk4j&quot;&gt;QQ的Sdk4j:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/debug/tx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;apache的commons-codec&quot;&gt;Apache的commons-codec:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/debug/apache.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/java_use_note/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/java_use_note/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>web应用分析利器-xrebel</title>
        <description>&lt;h4 id=&quot;xrebel-是不间断运行在-web-应用的交互式分析器当发现问题会在浏览器中显示警告信息xrebel-会实时监测应用代码的性能指标和可能会发生的问题&quot;&gt;XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。&lt;/h4&gt;
&lt;h4 id=&quot;看名称跟之前的jrebel有点相像对了是同一家公司的产品jrebel解决java项目动态部署xrebel解决j2ee应用的交互式分析甚至sql都能分析到强悍得不要不要的&quot;&gt;看名称跟之前的jrebel有点相像，对了，是同一家公司的产品，jrebel解决java项目动态部署，xrebel解决j2ee应用的交互式分析（甚至sql都能分析到，强悍得不要不要的）。&lt;/h4&gt;

&lt;p&gt;XRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/&lt;/p&gt;

&lt;p&gt;官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license
ps:没有license只有14天的试用版。xrebel跟jrebel的license不相同，jrebel只要有非死不可的账号就能永久免费，但是xrebel不行，不过我们可以利用现在激活的license server（http://idea.lanyus.com）。&lt;/p&gt;

&lt;h3 id=&quot;1下面以eclipse作为安装介绍idea差不多&quot;&gt;1、下面以eclipse作为安装介绍，idea差不多。&lt;/h3&gt;

&lt;p&gt;先进eclipse market下载xrebel插件：
&lt;img src=&quot;/images/posts/xrebel/market.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2在j2ee应用中使用xrebel&quot;&gt;2、在j2ee应用中使用xrebel：&lt;/h3&gt;

&lt;p&gt;xrebel插件工作：
&lt;img src=&quot;/images/posts/xrebel/config.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3启动j2ee应用观察控制台上的xreble信息&quot;&gt;3、启动j2ee应用，观察控制台上的xreble信息。&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/start.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4启动正常后观察最后的访问信息&quot;&gt;4、启动正常后，观察最后的访问信息&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/port.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5访问xrebelhttplocalhost8081xrebel并进入license设置&quot;&gt;5、访问xrebel，http://localhost:8081/xrebel，并进入license设置。&lt;/h3&gt;

&lt;h4 id=&quot;选择lanyu大神的在线jrebel和xreble服务白色的地方填写自己的名称即可邮箱可以随便填只要满足邮箱校验即可然后填写activate-licenseok激活成功&quot;&gt;选择lanyu大神的在线jrebel和xreble服务，白色的地方填写自己的名称即可，邮箱可以随便填，只要满足邮箱校验即可。然后填写activate license，ok，激活成功。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/active.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6激活成功xrebel后建议切换到离线模式&quot;&gt;6、激活成功xrebel后，建议切换到离线模式。&lt;/h3&gt;

&lt;h4 id=&quot;因为提供licesne服务的是lanyu大神的个人服务器有可能会被xrebel弄进黑名单或暂时没法连上offline模式可以管好几个月&quot;&gt;因为提供licesne服务的是lanyu大神的个人服务器，有可能会被xrebel弄进黑名单或暂时没法连上，offline模式可以管好几个月。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/license-offline.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;7配置成功后重启下j2ee应用可以再控制台多看到一个xrebel相关的license信息&quot;&gt;7、配置成功后，重启下j2ee应用，可以再控制台多看到一个xrebel相关的license信息。&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/license.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;8然后查看web项目的分析内容不是一般的强悍从contrl到dao都展示出来了&quot;&gt;8、然后查看web项目的分析内容，不是一般的强悍，从contrl到dao，都展示出来了&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/xrebel/xrebel.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;好了开始你的分析之路吧&quot;&gt;好了，开始你的分析之路吧&lt;/h2&gt;
</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/xrebel/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/xrebel/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>给你的静态博客增加留言系统</title>
        <description>&lt;p&gt;Gitment 是作者&lt;a href=&quot;https://imsun.net/posts/gitment-introduction/&quot;&gt;imsun&lt;/a&gt;实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。&lt;/p&gt;

&lt;p&gt;本博客评论系统已迁移至 Gitment，参考作者的介绍部署成功，不过这里补充详细点，方便新手入门。&lt;/p&gt;

&lt;h3 id=&quot;1注册-oauth-application&quot;&gt;1、注册 OAuth Application&lt;/h3&gt;

&lt;p&gt;通过地址&lt;a href=&quot;https://github.com/settings/applications/new&quot;&gt;传送门&lt;/a&gt;申请配置，注册一个新的 OAuth Application，其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://anttutu.github.io）。
&lt;img src=&quot;/images/posts/gitment/OAuth.jpg&quot; alt=&quot;&quot; /&gt;
创建成功后，你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。
&lt;img src=&quot;/images/posts/gitment/id.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2引入-gitment&quot;&gt;2、引入 Gitment&lt;/h3&gt;

&lt;p&gt;将下面的代码添加到你的页面：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;container&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&amp;gt;
&amp;lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
var gitment = new Gitment({
  id: '页面 ID', // 可选。默认为 location.href  比如我本人的就删除了
  owner: '你的 GitHub Name',              //比如我的叫anTtutu
  repo: '存储评论的 repo',                 //比如我的叫anTtutu.github.io
  oauth: {
    client_id: '你的 client ID',          //比如我的828***********
    client_secret: '你的 client secret',  //比如我的49e************************
  },
})
gitment.render('container')
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;为了灵活我在_configyml中配置好全局参数&quot;&gt;为了灵活，我在_config.yml中配置好全局参数：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/gitment/config.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3初始化评论&quot;&gt;3、初始化评论&lt;/h3&gt;

&lt;p&gt;页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。&lt;/p&gt;

&lt;p&gt;之后其他用户即可在该页面发表评论&lt;/p&gt;

&lt;h2 id=&quot;初始化点击下初始化即可&quot;&gt;初始化：点击下初始化即可&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/gitment/init.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;正常&quot;&gt;正常：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/gitment/comment2.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;/images/posts/gitment/comment.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;异常通常是repo或者owner配置不对请细心检测errornot-found--图1还有本地调测会出现callback不对提示error-comments-not-initialized-图2&quot;&gt;异常：通常是repo或者owner配置不对，请细心检测Error：Not Found  图1。还有本地调测会出现callback不对提示Error: Comments Not Initialized 图2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/gitment/Error1.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;/images/posts/gitment/Error3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/gitment/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/gitment/</guid>
        
        <category>github</category>
        
        
      </item>
    
      <item>
        <title>开发技能-shell面试整理</title>
        <description>&lt;h3 id=&quot;1常规命令&quot;&gt;1、常规命令&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd 切换目录 
ls 查看当前目录下的内容 
cp 复制 
head、tail 显示文件头、尾内容 
cat 查看文件内容 
more、less 分页展示文件内容 
rm 删除 
tar 解、压缩 
touch 创建文本 
mv 移动或重命名 
find 在文件系统中搜索某文件 如find . -name filename 支持正则 
wc 统计 
grep 查找某个字符串 
pwd 显示当前目录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2系统管理命令&quot;&gt;2、系统管理命令&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su 切换用户 
ps 查看进程 
kill 根据pid号杀进程 
who 显示在线账号 
whoami 显示当前操作账号 
hostname 显示主机名 
uname 显示系统信息 
top 动态显示当前资源消耗 
du 查看目录大小 
df 查看磁盘大小 
ping 测试网络是否连通，丢包 
ifocnfig 查看网卡 
man 帮助 
clear 清屏 
alias 对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit 
netstat 显示网络状态 
free 显示内存使用情况 
sar 1 20 以20次显示当前系统资源占用情况，最终显示这20次的平均值 
export 设置环境变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3linux管道&quot;&gt;3、Linux管道&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 
例：grep -r “close” /home/* | more 在home目录下所有文件中查找，包括close的文件，并分页输出。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4用户及用户组管理&quot;&gt;4、用户及用户组管理&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/etc/passwd 存储用户账号 
/etc/group 存储组账号 
/etc/shadow 存储用户账号的密码 
/etc/gshadow 存储用户组账号的密码 
useradd 用户名 
userdel 用户名 
groupadd 组名 
groupdel 组名 
passwd root 给root设置密码 
/etc/profile 系统环境变量 
bash_profile 用户环境变量 
.bashrc 用户环境变量 
su user 切换用户，加载配置文件.bashrc 
su - user 切换用户，加载配置文件/etc/profile ，加载bash_profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5更改文件的用户及用户组&quot;&gt;5、更改文件的用户及用户组&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chown [-R] owner[:group] {File|Directory}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6文件权限管理&quot;&gt;6、文件权限管理&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;三种基本权限 
R 读 数值表示为4 
W 写 数值表示为2 
X 可执行 数值表示为1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7更改权限&quot;&gt;7、更改权限&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录/文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8vim使用&quot;&gt;8、vim使用&lt;/h3&gt;
&lt;p&gt;vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 
命令模式下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:q 退出 
:q! 强制退出 
:wq 保存并退出 
:set number 显示行号 
:set nonumber 隐藏行号 
/apache 在文档中查找apache 按n跳到下一个，shift+n上一个 
yyp 复制光标所在行，并粘贴 
h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;9shell-script使用&quot;&gt;9、shell script使用&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 注释 
$? 前一个命令执行结果，0成功 1失败 
$# 统计传递的参数个数 
$0 在脚本中获取当前脚本名称 
$$ shell本身的processid 
$1 ~ n 获取第1 ~ n个参数 
$@ 所有参数 
sh -n 检测脚本是否有错，语法错或者字符错 
sh -x 调测模式 
tee 将数据输出到标准输出设备(屏幕) 和文件比如：command | tee outfile 
&amp;gt; 覆盖输出 
&amp;gt;&amp;gt; 追加输出 
expr 进行数学运算 如：expr $n + 1 
read 输入，如read a 
basename file 返回不包含路径的文件名比如： basename /bin/tux将返回 tux 
dirname file 返回文件所在路径比如：dirname /bin/tux将返回 /bin 
sort 默认以第一个数据来排序，而且默认是以字符串形式来排序,所以由字母 a 开始升序排序 
uniq 可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的 
awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符 
sed 一个基本的查找替换程序 
怎么让脚本后台执行 ./test.sh &amp;amp; 
nohup 永久执行 
EOF 通常与”&amp;lt;&amp;lt;”结合使用，”&amp;lt;&amp;lt;EOF”表示后续的输入作为子命令或子shell的输入，直到遇到”EOF”，再次返回到主调shell 
如： 
sqlplus testuser/testpwd &amp;lt;&amp;lt;EOF 
select sysdate from dual; 
EOF 

$SHELL 查看当前的shell语法类型 如：bash ksh csh 
$home 当前用户的家目录，就是创建用户时制定的根目录，如：root的是~ 
$PATH 环境变量，每个目录中间以“：”分割 
./test.sh、test.sh、sh test.sh 3种方式执行脚本的区别，为什么会这样？ 
脚本中的交互： 
send 用于向进程发送字符串 
expect 从进程接收字符串 
spawn 启动新的进程 
interact 允许用户交互 
如： 
#!/usr/bin/expect 
spawn ssh sshuser@192.168.22.194 
expect &quot;*password:&quot; 
send &quot;123\r&quot; 
expect &quot;*#&quot; 
interact 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;10判断&quot;&gt;10、判断：&lt;/h3&gt;

&lt;p&gt;通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ -f “somefile” ] ：判断是否是一个文件 
[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限 
[ -n “$var” ] ：判断var变量是否有值[“$a”=“$b”]：判断a和$b是否相等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;检查文件类型&quot;&gt;检查文件类型：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-e  文件是否存在   test -e filename
-f  文件是否存在，且为文件 file
-d  文件是否存在，且为目录 directory
-b  文件是否存在，且为block device设备
-c  文件是否存在，且为character device设备
-S  文件是否存在，且为Socket文件
-p  文件是否存在，且为FIFO(pipe)文件
-L  文件是否存在，且为连接文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;检查文件权限&quot;&gt;检查文件权限：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-r  文件是否存在，且可读权限
-w  文件是否存在，且可写权限
-x  文件是否存在，且可执行权限
-u  文件是否存在，且具有SUID属性
-g  文件是否存在，且具有SGID属性
-k  文件是否存在，且具有 Sticky bit 属性
-s  文件是否存在，且为 非空白文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;两个文件比较&quot;&gt;两个文件比较：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-nt  newer than 判断file1是否比file2新     如：test file1 -nt file2
-ot  older than 判断file1是否比file2旧
-ef  判断是否为同一文件，可用在判断hard link上，判定两个文件是否指向同一个inode 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;两个整数的判断&quot;&gt;两个整数的判断：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-eq  equal 相等，  test n1 -eq n2
-ne  not equal 不相等
-gt  greater than 大于
-lt  less than 小于
-ge  greater than or equal 大于等于
-le  less than or equal 小于等于
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;判定字符串&quot;&gt;判定字符串：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test -z string  判断字符串是否为0， string为空，返回true，  test -z string
test -n string  判断字符串是否非为0， string 为空， 返回false， -n可省略
test str1 = str2 是否相等
test str1 != str2 是否不相等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;多重条件&quot;&gt;多重条件：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-a 同时成立，and  ， test -r file -a -x file : file同时具有rx权限时，返回true
-o 任意一个成立， or
!  取反
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;流程控制&quot;&gt;流程控制：&lt;/h4&gt;
&lt;p&gt;if
“if” 表达式 如果条件为真则执行then后面的部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ….; then 
…. 
elif ….; then 
…. 
else 
…. 
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;case
case表达式可以用来匹配一个给定的字符串，而不是数字。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case … in 
…) do something here ;; 
esac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select
select结构从技术角度看不能算是循环结构，只是相似而已，它是bash的扩展结构用于交互式菜单显示，功能类似于case结构比case的交互性要好&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select color in “red” “blue” “green” “white” “black” 
do 
break 
done 
echo “You have selected $color”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;loop
while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true. 
关键字”break” 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while …; do 
…. 
done

进入循环：满足 
退出循环：不满足
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;until …; do 
…. 
done

进入循环：不满足 
退出循环：满足 
退出值不为0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for var in ….; do 
…. 
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;抓包&quot;&gt;抓包：&lt;/h4&gt;

&lt;p&gt;Linux： 
tcpdump&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-i 监听的网口，比如eth0 
-w 写文件，带文件名 
-s 设置缓存字节数 
-c 抓包次数 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;windows: 
fiddler wireshark(同时可以看包的报文)&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/shell_check/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/shell_check/</guid>
        
        <category>shell</category>
        
        
      </item>
    
  </channel>
</rss>
