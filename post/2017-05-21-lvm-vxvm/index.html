<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>VCS第五波-磁阵管理LVM和VxVM1-LVM | Anttu&#39;s Blog</title>
    <meta property="og:title" content="VCS第五波-磁阵管理LVM和VxVM1-LVM - Anttu&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2017-05-21T21:46:20&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2017-05-21T21:46:20&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,anttu,java,博客,bash,linux笔记,python笔记,公众号,小程序">
    <meta name="description" content="磁阵管理LVM和VxVM">
        
    <meta name="author" content="Anttu">
    <meta property="og:url" content="https://anTtutu.github.io/post/2017-05-21-lvm-vxvm/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://anTtutu.github.io/">
                        Anttu&#39;s Blog
                    </a>
                
                <p class="description">一位Java开发者，喜欢研究技术，同时也在学习Golang和Python中，对服务器、Linux使用比较熟悉。欢迎添加技术交流QQ群：655158296</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://anTtutu.github.io/">首页</a>
                    
                    <a  href="https://anTtutu.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://anTtutu.github.io/tags/" title="分类">分类</a>
                    
                    <a  href="https://anTtutu.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#1谈谈lvm的命令目前linux下用的是20版本兼容早期的11版本常用命令">1、谈谈LVM的命令，目前linux下用的是2.0版本，兼容早期的1.1版本，常用命令：</a></li>
        <li><a href="#1-pvdisplay">1. pvdisplay</a></li>
        <li><a href="#2-pvcreate">2. pvcreate</a></li>
        <li><a href="#3-pvremove">3. pvremove</a></li>
        <li><a href="#4--pvchange">4.  pvchange</a></li>
        <li><a href="#5-vgdisplay">5. vgdisplay</a></li>
        <li><a href="#6-vgchange">6. vgchange</a></li>
        <li><a href="#7-vgcreate">7. vgcreate</a></li>
        <li><a href="#8--vgextend">8.  vgextend</a></li>
        <li><a href="#9-vgreduce">9. vgreduce</a></li>
        <li><a href="#10-vgremove">10. Vgremove</a></li>
        <li><a href="#11--vgmodify">11.  Vgmodify</a></li>
        <li><a href="#12-lvdisplay">12. lvdisplay</a></li>
        <li><a href="#13-lvcreate">13. lvcreate</a></li>
        <li><a href="#14-lvextend">14. lvextend</a></li>
        <li><a href="#15-lvreduce">15. lvreduce</a></li>
        <li><a href="#16-lvremove">16. lvremove</a></li>
        <li><a href="#17-vgexpot">17. vgexpot</a></li>
        <li><a href="#18-vgimport">18. vgimport</a></li>
        <li><a href="#19-vgcfgbackup">19. vgcfgbackup</a></li>
        <li><a href="#20-vgcfgrestore">20. vgcfgrestore</a></li>
        <li><a href="#21-vgscan">21. vgscan</a></li>
        <li><a href="#22-newfs">22. newfs</a></li>
        <li><a href="#23-fsck">23. fsck</a></li>
        <li><a href="#24-mount">24. mount</a></li>
        <li><a href="#25-umount">25. umount</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">VCS第五波-磁阵管理LVM和VxVM1-LVM</h1>
        </header>
        <date class="post-meta meta-date">
            2017年5月21日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://anTtutu.github.io/categories/vcs'>vcs</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="clear" style="display: none">
            <div class="toc-article">
                <div class="toc-title">文章目录</div>
            </div>
        </div>
        
        <div class="post-content">
            <h4 id="使用vcs双机经常要跟磁阵打交道磁阵的逻辑卷组管理也有不同厂之间的方案比如免费的系统自带的lvmlinux的lvm与unix的lvm还有点不同veritas的vxvm">使用VCS双机经常要跟磁阵打交道，磁阵的逻辑卷组管理也有不同厂之间的方案，比如免费的系统自带的lvm，Linux的lvm与unix的lvm还有点不同，Veritas的VxVM，</h4>
<h4 id="对比下呢各有千秋lvm免费成本低但集群管理也比较方便和省成本相同的设备做容灾也可以应用但是不同设备之间做容灾的话就有点麻烦了这个依赖于项目的要求和财务实力了vxvm在linuxunixhp-unixsolaris都有版本可以跨平台但是容灾方案一般不太建议跨平台做比较难于设计和难于维护建议在财务允许情况下采用相同的硬件设备">对比下呢，各有千秋，lvm免费成本低，但集群管理也比较方便和省成本，相同的设备做容灾也可以应用，但是不同设备之间做容灾的话就有点麻烦了，这个依赖于项目的要求和财务实力了，VxVM在linux、unix、HP-Unix、Solaris都有版本，可以跨平台，但是容灾方案一般不太建议跨平台做，比较难于设计和难于维护，建议在财务允许情况下采用相同的硬件设备。</h4>
<h3 id="1谈谈lvm的命令目前linux下用的是20版本兼容早期的11版本常用命令">1、谈谈LVM的命令，目前linux下用的是2.0版本，兼容早期的1.1版本，常用命令：</h3>
<pre><code>pvdisplay  
pvcreate  
pvremove  
pvchange  
vgdisplay  
vgchange  
vgcreate  
vgextend  
vgreduce  
vgremove  
lvdisplay  
lvcreate  
lvextend  
lvreduce  
lvremove  
vgexpot  
vgimport  
vgcfgbackup  
vgcfgrestore  
vgscan  
newfs  
fsck  
mount  
umount  
</code></pre><h3 id="1-pvdisplay">1. pvdisplay</h3>
<pre><code>pvdisplay [-v] [-b BlockList] pv_path   
pvdisplay -l [-u] pv_path    
  
-v    详细显示pv信息，包括每个block    
-b    BlockList   显示指定block的信息，可以用于查看该block 所属的lv，pe及其状态    
-l     显示该盘是否为lvm disk   
  
例:   
  
# pvdisplay -b 04183 /dev/dsk/c1t6d0   
  
过程：  该命令首先检查所要查看的pv是否在lvmtab中，如果在读取该pv所属vg的的group id，然后再从内存中查找该vg的信息，获取相应pv的信息。   
  
注：    
1、只有被lvm管理且所属vg激活的pv才能够通过该命令察看到该盘的lvm信息，     
2、当一块硬盘的盘头信息被破坏，而所属的vg仍然激活时，该信息仍然能够被显示出来，所以该命令是显示的信息是从内存中读取而非盘头直接读取的。    
3、有此可见当vg激活时，pv状态正常并不一定能够说明该盘状态正常。     
</code></pre><h3 id="2-pvcreate">2. pvcreate</h3>
<pre><code>pvcreate [-b] [-B] [-d soft_defects] [-s disk_size] [-f] [-t disk_type] pv_path     
-B   创建boot盘，预留boot区，后用mkboot创建BDRA区，故pvcreate –B并不创建BDRA区    
-f   强制创建，即使disk上存在数据或曾经被lvm管理过。   
-s   disk_size  定义pv有效扇区的数量    
-t   disk_type  当pvcreate无法返回pv的大小时，需要指定设备类型， 如hp7959S，如不加disk_type则获取pv的设备信息。    
-d  soft_defects   指定BBR区block的最小数量，此值不能超过7039，默认为每8k一个block,   
例 :    
pvcreate –f /dev/rdsk/c0t1d0 pvcreate –B /dev/rdsk/c0t1d0   
  
注：    
该命令重建PV的盘头信息，该命令用主机的CPU number和创建的时间生成一个唯一的PVID，并将其写入PVRA中用以标识每个PV，pv的盘头信息每个区大小固定，该命令只对盘头信息进行重建，对其他区如数据区的内容不作任何改变，故一个盘被重新pvcreate后用vgcfgrestore恢复其vg信息后，该盘上的数据不会丢失，仍可使用（不建议使用）。   
  
1、 如果该盘包含PVRA区（即曾经被pvcreate过），不加-f 会报该盘被使用，但如果加了-f就会忽略该信息，重建PVRA区。所以当提示该信息时我们要进行确认该盘没有在当前系统或能识别到该盘的其它系统使用，或确认该盘上数据不需要了。    
2、 如果该盘包含在lvmtab或lvmtab_p中，执行该命令会报该盘已记录在lvmtab中，但如果将lvmtab mv掉，该命令仍将成功，这说明该命令仅检测lvmtab及盘头信息，即使该盘所属的vg仍然处于激活状态，此时如果用vgdisplay 检查vg，会发现该盘状态为unavailable。    
3、 一个盘被重新pvcreate后，其上的VGRA的信息也将被删除，所有lv的信息也将被删除。     
</code></pre><h3 id="3-pvremove">3. pvremove</h3>
<pre><code>pvremove pv_path （rdsk设备）  用于删除一个pv的LVM机构信息，删除后该pv不再是一个LVM结构的盘。   
  
该命令检查该硬盘的盘头信息，如果发现该盘包含VGRA的信息，则提示改判属于某个vg，无法完成（即使该vg已经不在lvmtab中，它仍然会报属于某个export掉的vg），需先用vgremove将该pv从vg中取出来（或者pvcreate 该盘）。    
  
注：  
该命令去除盘头的LVM信息，该信息删除后可以用vgcfgrestore（要先做pvcreate，而且该命令执行成功后，pvcreate 不加-f 也可成功执行）。     
</code></pre><h3 id="4--pvchange">4.  pvchange</h3>
<pre><code>pvchange [-A autobackup] -s pv_path          
pvchange [-A autobackup] -S autoswitch pv_path         
pvchange [-A autobackup] -x extensibility pv_path         
pvchange [-A autobackup] -t IO_timeout pv_path         
pvchange [-A autobackup] -z sparepv pv_path    
改变一个pv在vg中的访问路径，但如果该vg以共享方式被激活时，该命令不能执行。   
  
-A：是否对所作的修改进行保存， y 保存，vgcfgbackup被执行，默认值；n不保存。   
-s立即执行使用其它路径访问该盘。    
-S 是否执行自动切换：y 当有一条更好的路径可用时进行切换，默认值；n 当有更好的路径可用时不切换，直至指定的路径不可用才切换到其它路径    
-t 设置pv不可访问的延时时间，超过该时间，驱动则认为该设备已坏。为0表示用该设备的默认值    
-z y  将一个vg内的pv转换成spare盘，n将spare盘转为一般的pv。旋转mirrodisk.   
  
例：    
当路径不可用时切换，且切换后即使原路径可用也不切换回来。   
pvchange -S n /dev/dsk/c0t0d0     
  
手动设置pv使用其它路径    
pvchange -s /dev/dsk/c2t0d2     
  
设置 IO_timeout 值到60秒    
pvchange -t 60 /dev/dsk/c2t0d2     
  
改变一个空盘成spare盘    
pvchange -z y /dev/dsk/c2t0d2     
</code></pre><h3 id="5-vgdisplay">5. vgdisplay</h3>
<pre><code>pvdisplay [-v] [-b BlockList] pv_path    
  
-v   详细显示vg的信息，包括lv及pv的简要信息。   
不加参数显示所有的vg信息。   
  
注：    
该命令首先从lvmtab中查找相应的vg，如果找不到则报该vg不存在，如找到获取该vg使用的硬盘，并读取盘头的信息，并和内存中读取vg的信息进行比较，如果内存中没有该vg的信息，则报vg没有激活。  如果lvmtab中的某块硬盘在内存中没有信息则报can’t query physical volume（这种情况一般发生在激活vg时这块盘的盘头信息已经不能访问造成内存中没有这块盘的信息），   
当vg激活后如果误操作将某块盘头信息删除，此时vgdisplay会报该盘处于unavailable状态，但此时该vg的lv仍能正常进行访问读写。但如果deactive后再激活该盘可能无法再访问。如果该盘处于no_hw，被访问的pe状态会处于stale，lv的状态会处于非同步状态。所以有时该命令显示的信息不能完全反映真实状态，当发现异常时不要轻易去激活vg，需及时查明原因进行处理，如果无法处理应及时进行数据备份。 其每次显示LV的设备文件名要通过min number在/dev/vg**下重新读取，也就是说如果lv的名称发生变化，对应显示出来的信息也会发生变化（修改lv名就这么简单，但要注意如果此时该lv正在使用，这种修改可能会造成lv无法访问，需要在应用进行修改），如果lv设备文件被删除则无法显示，同时cur lv和open lv的值不同。   如果在激活之前其中一块硬盘不正常（盘头信息不正常或者盘不能访问），则该盘在激活过程中就无法将该盘的盘头信息读入内存，激活后该vg就会报can’t query physical volume，同时所显示的act pv（激活的pv数量）就会比cur pv（盘头信息中该vg包含的pv数量）少一个。     
</code></pre><h3 id="6-vgchange">6. vgchange</h3>
<pre><code>vgchange –a y 以普通模式激活VG        
vgchange –a y –q n 以去掉qurom的方式激活vg        
vgchange –a e 以独享方式激活vg,一般为cluster中的vg,设置成exclusive VG    
vgchange –c y  添加exclusive属性    
vgchange –c y –S y 添加exclusive和share属性        
vgchange  -c n  去除exclusive属性，如果该vg原来是share方式，执行该命令后也将变成普通的vg，不需要执行-S n      
  
注：        
该命令用于激活VG，将其信息加载到内存中，过程如下：操作系统根据VG名称从lvmtab中找到对应的VG，读出相应的VGID和对应PV的设备文件名信息，同时查找/dev下的的vg，找到对应vg的group文件的mag number。根据PV的设备文件名，找到相应的所有的PV，读取各个盘头信息及该盘的状态，进行比较，看是否一致，如果不一致，则选择系统认为正常的pv的盘头信息，激活该pv，并和lvmtab中读取的vgid进行核对，没有问题在内存中添加相应的表空间，并建立和mag number的对应关系。可见看似简单的vgchange其实很不简单，再遇到vg无法激活的情况可参照进行检查是哪出了问题。  如果lvmtab中的pv数量少于该vg实际应该包含的pv数量（这种情况常发生于MC环境，一台主机增加了pv，而另外一台主机没有重新vgimport更新信息）。那么vg激活时lvm不会去加载lvm中缺少的pv的盘头信息到内存中，但是由于检测到的含有该vgid的实际pv数量于lvmtab值，所以系统激活时仍会检测出该错误并会报：some physical volume(s) are missing. 激活后cur pv数量等于实际找到的pv的数量，会大于act pv的数量，但系统不会报，can’t query physical volume,但该pv上的lv将都处于不可用状态。  如果lvmtab中的pv数量大于该vg实际应该包含的pv数量，lvm仍然回去检查多于pv的盘头信息，如果这个pv仍然包含有该vg的盘头信息，该pv仍然会被激活加载到内存中，此时显示的cur pv数量为lvmtab中的数量。如果这个pv不包含该vg的盘头信息，则系统会报can’t query physical volume，cur pv数量仍为lvmtab中的数量，会大于act pv的数量。   
在VGRA中记录了VG的激活方式，所以我们必须根据VG的特点选择对应的激活方式。      
</code></pre><h3 id="7-vgcreate">7. vgcreate</h3>
<pre><code>创建vg，并在创建vg的硬盘上创建VGRA区。    
vgcreate [-f] [-A autobackup] [-x extensibility] [-e max_pe] [-l max_lv] [-p max_pv] [-s pe_size] [-g pvg_name] vg_name pv_path ...    
  
－f   强制执行，即使该 pv含数据或属于某个vg.    
－l max_lv   一个vg内lv的最大数量，（默认值255个）   
－e max_pe   PE/Pv最大值（默认1016个，最大值65535）    
－p max_pv   一个vg内pv的最大数量（默认16个，最大值255个）   
－s pe_size  设置pe的大小 （默认4M，最大值256），   
  
例：    
# mkdir /dev/vg01    
# mknod /dev/vg01/group c 64 0x010000   
# chown –R root:sys /dev/vg01   
# chmod 755 /dev/vg01    
# chmod 640 /dev/vg01/group    
# vgcreate vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0     
  
Specify the maximum number of LVs allowed in the VG (Default: 255)   
# vgcreate –l 1-255 vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0    
Specify the maximum number of PVs allowed in the VG (Default: 16)   
# vgcreate –p 1-255 vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0   
Specify the extent size (Default: 4MB)    
# vgcreate –s 1-256 vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0    
Specify the maximum PE/PV (Default: 1016, or the number of PEs on largest initial disk)    
# vgcreate –e 1-65535 vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0      
  
过程：    
首先系统检查当前lvmtab中是否包含该pv，如果包含则提示，该盘已被使用，如果没有包含，检察使用的vg名称和group id是否合系统中已和lvmtab中的vg信息冲突，如果相同，则提示该vg已使用，该命令成功后会每块硬盘上创建vgra区，并写入相同的vgid，同时在lvmtab中创建相关信息。 注：  如果使用的盘包含其它vg的信息则会提示该盘被其它vg使用，需要重新pvcreate后才能重新使用。  盘头大小为1个pe，最主要使用区域为LV entry和pv entry，如果没有指定按照默认的max_lv和max_pv保留该区域，如果创建vg的硬盘比较大（即使没有超过65535个pe空间），造成每个pv entry使用的空间比较多，将造成该区域超过1个pe的大小，造成该命令失败。比如使用1块146G大小的盘创建vg，不指定任何参数，系统将提示该盘使用的pe数量超  
过35003个，需要制定pe size。这时我们我们可以通过增大pe size进而减少pe 数量的方式，也可以通过指定pv和lv的最大数量方式保证盘头信息不超过1个pe大小。  如果不指定－p max_pv参数，该vg最大能扩展的pv只有16个，对于很多用户来说这个值可能将来不够，所以在创建vg时要针对情况修改这一参数。  创建vg时如果不指定－e max_pe 参数，则该vg会根据创建时最大硬盘盘的大小除以pe size所得的值为将来该vg每个pv所能包含最大pe的数量，那么将来如果需要扩盘最大能够使用的盘的大小也就是这块盘的大小，多出部分则无法使用。  创建vg时指定的很多参数已经设定（或不设定，使用默认值）则无法修改，需要重建vg才能重建这些参数。  系统中的内核参数max_vg设定，如果这一值对于客户将来的业务发展可能不够的话建议尽早修改，避免后期修改需要重起主机。  
</code></pre><h3 id="8--vgextend">8.  vgextend</h3>
<pre><code>vgextend [-f] [-A autobackup] [-g pvg_name] [-x extensibility] [-z sparepv] vg_name pv_path ... 添加pv扩展vg    
  
-A是否对所作的修改进行保存， y 保存，vgcfgbackup被执行，默认值；n不保存。   
-x 可扩展性设置    
-z  添加入的盘作为spare盘使用或普通盘使用。y为spare  n为普通盘   
  
例：    
vgextend /dev/vg03 /dev/dsk/c0t1d0 /dev/dsk/c0t2d0   
向pvg0上的vg03加载两块硬盘    
vgextend -g PVG0 /dev/vg03 /dev/dsk/c0t3d0 /dev/dsk/c0t4d0   
添加一块host spare盘    
vgextend -z y /dev/vg03 /dev/dsk/c2t4d0   
    
注：  
vg共享激活时不可使用该命令  对于多路径硬盘，用vgextend还可用于添加多路径，如果客户没有使用多路径软件，使用系统的pv link功能，系统按照lvmtab中的顺序使用路径进行读写，并且不具备balance功能，仅起到链路切换的功能，有些多路径软件并不聚合路径，但具有balance功能（当然同时也需要存储本身支持），如powerpath，那么即使vg中仅包含其中一条路径，IO仍然会分布在多条路径上，并且即使这条路径损害，也仍然可以对该盘进行访问。  
</code></pre><h3 id="9-vgreduce">9. vgreduce</h3>
<pre><code>/usr/sbin/vgreduce [-A autobackup] vg_name pv_path ...         
/usr/sbin/vgreduce [-A autobackup] [-l] vg_name pv_path         
/usr/sbin/vgreduce [-A autobackup] [-f] vg_name 从vg中删除pv    
  
-A是否对所作的修改进行保存， y 保存，vgcfgbackup被执行，默认值；n不保存。   
－f 删除vg中丢失的pv，所谓丢失的pv主要是当cur pv大于act pv是，将没有被加载如内存中的pv去掉，该步骤同样需要该pv上没有lv的信息。  
-l删除lvmtab中pv的信息，同时清除掉该盘盘头中vgid的信息（当然如果该盘不能访问则忽略改步骤），同样要求该pv上不能含有lv信息。     
  
例：    
从vg01中去除c0t1d0    
vgreduce /dev/vg01 /dev/dsk/c0t1d0       
将vg01中丢失的pv全部去掉，    
vgreduce -f /dev/vg01    
将vg01中标示为丢失的pv去除（虽然还在lvmtab中）    
PV with key 0 successfully deleted from vg /dev/vg01 Repair done, please do the following steps.....:   
1.  Save /etc/lvmtab to another file.   
2.  Remove /etc/lvmtab.    
3.  Use vgscan -v to recreate /etc/lvmtab.    
4.  NOW use vgcfgbackup(1M) to save the LVM setup.   
  
vgreduce -l /dev/vg01   
  
注：    
该命令仅删除lvmtab中pv的信息，并将内存中的pv的信息清除掉，同时将信息保存到/etc/lvmconf/vgname.conf中，不会真正修改被删除pv的盘头信息。  当有多条路径时须将每条路径都删除才能将pv删掉，否则如果删除的是主路径（在用的），则辅路径被使用。vg中最后一个pv不能被删除。  当被删除的pv上包含lv的信息时，该pv无法被删除，即使使用-f参数。  
</code></pre><h3 id="10-vgremove">10. Vgremove</h3>
<pre><code>vgremove vg_name ...    
在系统中删除指定的vg，删除前要求该vg中只剩下一个pv,同时所有的lv均已被删除。   
  
例：    
vgremove /dev/vg02   
  
注：    
使用该命令后，lvmtab中vg的信息和盘头中的vgid信息被删除。盘头其他信息及系统中的设备文件将不会被删除。即使该vg 处于激活状态该命令仍将vg删除掉。     
</code></pre><h3 id="11--vgmodify">11.  Vgmodify</h3>
<pre><code>vgmodify - 处理现有LVM 卷组的物理卷大小更改以及修改其配置参数    
  
-e max_pe 设置可从卷组中任何物理卷分配的最大物理盘区数（请参阅vgcreate(1M) -e）    
-l max_lv 设置卷组中允许包含的最大逻辑卷数（请参阅vgcreate(1M) -l）。   
-o 优化卷组设置。尽可能上调盘区和物理卷的最大数量，以便充分利用每个物理卷 上为LVM 配置数据保留的空间。  
  
此选项不能与-l、-p、-n、-t 或-e 一起使用。    
-p max_pv 设置卷组中允许包含的最大物理卷数（请参阅vgcreate(1M) -p）   
-r 报告所使用的其他选项的效果。不会对卷组进行任何更改。    
-t 生成一个显示卷组的最佳可能设置（max_pe、max_pv 和最大磁盘大小）的表。     
  
将每个物理卷的最大物理盘区数设置为4000，将最大物理卷数设置为50，并尽可能利用盘区重新编号：    
vgmodify -p 50 -e 4000 -n /dev/vg02   
详细检查（不更改）优化卷组设置的影响：   
vgmodify -v -r -o /dev/vg02    
详细应用由优化卷组设置所导致的更改：    
vgmodify -v -o /dev/vg02    
如果vgmodify 命令发生中断，可以输入以下内容为卷组中的所有物理卷恢复新配置：   
/etc/lvmconf/vg02_restore /etc/lvmconf/vg02.conf  
</code></pre><h3 id="12-lvdisplay">12. lvdisplay</h3>
<pre><code>lvdisplay [-k] [-v] lv_path   
  
-v  详细显示该lv的信息。    
-k   同-v，除了显示pvkey(Physical Volume Number in VG),而非pvname。   
  
注：    
如果lv所属的pv在vg激活状态出现盘头信息不正常（如被强制pvcreate），此时你看到lvdisplayde 状态的状态仍将正常，该lv也能正常访问，但如果此时如果你对该lv进行操作如lvextend，那么该lv lvdisplay的状态虽然仍将正常，但此时该lv将不能访问，比如是文件系统的话bdf将看到该lv报I/O error。这是因为通常情况下对lv的操作都是通过内存中的信息进行的，该信息在不进行lvm修改操作或重新激活vg的情况下一般不会进行更新。  如果硬盘故障lv在进行io读写时出现错误，被访问的lv会处于stale状态，其他没有被访问的lv仍处于current状态。
</code></pre><h3 id="13-lvcreate">13. lvcreate</h3>
<pre><code>lvcreate [-A autobackup] [-c mirror_consistency] [-C contiguous] [-d schedule] [-D distributed] [-i stripes -I stripe_size] [-l le_number | -L lv_size] [-m mirror_copies] [-M mirror_write_cache] [-n lv_name] [-p permission] [-r relocate] [-s strict] vg_name 创建lv    
  
-d   当设置了mirror时，设置向原盘和mirro 盘写方式，  
-p 为Parallel –s 为Sequential方式：   
  
例如：
Create a mirrored LV using the parallel scheduling policy:   
# lvcreate –L 32 –n data –m 1 –d p  vg01    
reate a mirrored LV using the sequential scheduling policy:   
# lvcreate –L 32 –n data –m 1 –d s  vg01   
Change the scheduling policy on an existing LV:   
# lvchange  –d p  /dev/vg01/data      
  
-c  数据一致性恢复设置，配合-M n参数使用，  
y：(默认) 系统crash后 nomwcsyncd 自动同步整个lv，对于大文件系统则需要花费比较长的时间。  
n :不进行恢复，常用于向swap这样的区域。     
  
-M  写缓冲设置    
•Create a 32-entry MWC table in memory to track pending write requests    
•Subdivide each LV into 256K “Logical Track Groups” (LTGs).    
•When an LTG has a pending write request, mark that LTG “dirty” in the MWC.   
•When a write request completes, mark that LTG “clean” in the MWC. How does LVM retain MWC information across reboots/crashes?   
•Create an MCR table in the VGRA on disk •If a write is scheduled to a new LTG, create an MWC entry and flush to the MCR on-disk   
•If a write is scheduled to an LTG already in the MWC, no need to flush   
•After a crash, LVM only resyncs LTGs listed in the MCR 有y（默认） n 两个参数   
  
例：   
Create an LV using the MWC consistency recovery policy   
# lvcreate –L 32 –m 1 –n data  –M y  vg01    
Create an LV using the NOMWC consistency recovery policy   
# lvcreate –L 32 –m 1 –n data  –M n –c y  vg01    
Create an LV with using the NONE consistency recovery policy   
# lvcreate –L 32 –m 1 –n data  –M n –c n  vg01    
Change the consistency recovery policy on an existing LV (umount required!)   
# umount /data    
# lvchange –M y /dev/vg01/data   
# mount /data     
  
-s mirror分布设置，g:PVG-Strict     并行分布在不同的pv上（需在不同的链路上）     
y:Strict 在不同的盘上   
n：Non-Strict可在同一块盘上。      
  
-l le的数量设置LV的大小（1－65535）    
-L LV的实际大小（以M为单位，1－1666772） 如果这两个值都没有设，默认值为0   
  
例：    
-n lv的名字，如没有则用lvol，  
-m  mirror数量的设置。  
  
注：  该命令仅在盘头创建相应的lv的信息，确定该lv使用那块pv的哪些pe，不会修改实际的数据区域（但mirror盘上的数据会被会被原判的数据同步）。   
Lvcreate 命令创建的lv无法指定硬盘，但可以通过先不指定lv大小，仅创建lv的名字，再通过lvextend命令方式将lv创建到指定的硬盘上。需要特别注意的是当vg中有多块盘，应尽量避免出现lv跨两块盘的状况（条带划除外）。  如果lv使用了条带划，那么以后如果扩盘用以扩展该lv，那么所扩盘的数量必须是创建时指定的-i stripes 的整数倍。  该命令同时在该vg目录中生成lv设备文件，所以在双击环境中需要通过vgimport命令同步设备文件的信息，通过mknod命令生成相应的设备文件。  
</code></pre><h3 id="14-lvextend">14. lvextend</h3>
<pre><code>lvextend [-A autobackup] {-l le_number | -L lv_size | -m mirror_copies} lv_path [pv_path ... | pvg_name ...] 增加空间或增加mirror    
  
-l le的数量设置LV的大小（1－65535）    
-L LV的实际大小（以M为单位，1－1666772）   
-m 设置mirror,     
  
例：    
增加lvol3到100个pe    
lvextend -l 100 /dev/vg01/lvol3   
增加lvol3到400M    
lvextend -L 400 /dev/vg01/lvol4   
在一个指定的硬盘上创建lv的mirror    
lvextend -m 1 /dev/vg00/lvol3 /dev/dsk/c0t3d0   
  
增加文件系统步骤：    
lvextend -L 400 /dev/vg06/lvol3   
umount /dev/vg06/lvol3    
extendfs /dev/vg06/rlvol3  (注意要使用带r的设备文件)   
mount /dev/vg06/lvol3 /mnt    
  
如果使用了onlineJFS 在线扩展文件系统   
lvextend -L 400 /dev/vg06/lvol3  fsadm –b 400M /mnt  （注意要加M 兆,否则默认单位为b，byte）    
  
注：    
使用lvextend扩展lv后，如果不指定硬盘，lvm会按照vg中pv key的顺序，寻找每一个没有分配的pe，将扩展的pe 按照空闲pe num从小到大顺序分配下去，所以使用该命令是要注意pv中pe的使用情况，避免造成lv过多的碎片。  
</code></pre><h3 id="15-lvreduce">15. lvreduce</h3>
<pre><code>lvreduce [-A autobackup] [-f] -l le_number lv_path        
lvreduce [-A autobackup] [-f] -L lv_size lv_path         
lvreduce [-A autobackup] -m mirror_copies lv_path  [pv_path ...]   
lvreduce [-A autobackup] -k -m mirror_copies lv_path 减少lv的空间或mirror的数量。      
-f 强制执行，如果较少到的空间小于数据空间，不会出现提示执行，数据将被破坏且无法mount,    
-k 针对missed盘删除lv，常配合-m 使用，    
  
例：    
减少lv到100个pe    
lvreduce -l 100 /dev/vg01/lvol3   
减少lv的mirror到一个    
lvreduce -m 1 /dev/vg01/lvol5   
去除mirror    
lvreduce -m 0 /dev/vg01/lvol4 /dev/dsk/c1t0d0    
  
注：    
Lvreduce 缩减lv大小命令本身是lvm层对pe数量的减少，不会对数据造成破坏，可以用lvextend命令将lv空间重新扩展为原来的大小（要确保所扩的实际pe的位置和原来的pe也要一样），但如果该操作是在该lv使用过程中操作，如为文件系统，且处于mount状态，该操作将造成文件系统结构的破坏，此时即使将lv重新扩展为原来的大小，数据仍将有可能会被破坏。另外由于原lv所使用的空间可能不连续，缩减后再lvextend 回去，所extend的pe可能不是原来该lv所使用的pe，这也仍将造成数据的破坏。 使用lvreduce 命令删减mirror，使用-k方式和普通方式的区别在于：不使用-k方式lvm会检查被删mirror盘的状态，同时将修改的信息试图写入被删mirror盘的盘头，使用-k方式，如果该盘无法访问则跳过该步骤，仅将信息写到该lv所在的其它盘头上。      
</code></pre><h3 id="16-lvremove">16. lvremove</h3>
<pre><code>lvremove [-A autobackup] [-f] lv_path ... 删除指定的lv    
  
-f 没有用户提示，直接强制执行。不加-f，系统会提示你敲y确认。  
  
例如    
lvremove -f /dev/vg01/lvol5   
  
注意：    
该命令仅删除盘头中该lv的信息，不删除实际数据，可以通过lvcreate 及lvextend命令重新恢复，但注意事项同上面lvreduce。  该命令同时会删除该vg目录中lv设备文件，所以在双击环境中需要通过vgimport命令同步设备文件的信息，或直接将该设备文件在另外一台主机中删除掉。  
</code></pre><h3 id="17-vgexpot">17. vgexpot</h3>
<pre><code>vgexport [-m mapfile] [-p] [-v] [-f outfile] vg_name   
vgexport -m mapfile -s -p -v vg_name   
导出vg信息或从系统中删除vg信息。   
  
-m  指定所存取的map名    
-p  执行命令但不从lvmtab中去除相应的vg及设备文件   
-v  显示执行过程及结果    
-f  将pv_path的信息写入outfile中    
-s  配和-v –p-m  命令使用，将vg信息写如一个map文件   
  
例如：   
vgexport vg01  导出vg，该操作从lvmtab中删除vg信息，并输出/dev/下对应vg的目录，设备文件，但对硬盘本身不做修改。   
vgexport  -m /tmp/vg01.map –p –s vg01    导出vg，并存到vg01.map中，且不从lvmtab中去除相应的vg及设备文件   
  
注：    
该操仅修改操作系统内关于vg的设备文件等信息，不会对硬盘造成破坏。  
</code></pre><h3 id="18-vgimport">18. vgimport</h3>
<pre><code>vgimport [-m mapfile] [-p] [-v] [-f infile] vg_name pv_path   
vgimport -m mapfile -s -v vg_name   
  
-m  指定所存取的map名    
-p  执行命令但不向lvmtab中加入相应的vg及设备文件   
-v  显示执行过程及结果    
-s  配和-v -m  命令使用，基于一个map文件向系统中导入相应的信息   
  
例如    
导入c0t1d0 c0t3d0上的vg01    
vgimport -v /dev/vg01 /dev/dsk/c0t1d0 /dev/dsk/c0t3d0 利用vg01.map加载vg01的信息    
vgimport –m /tmp/vg01.map –s vg01   
  
过程：    
  
注：    
vgimport操作一般包含以下几种方式： 有map文件等情况下两种情况，一种情况是普通的硬盘（即c*t*d*或11iv3的disk*设备），vgimport -v -s -m /tmp/vg01.map /dev/vg01，   另一种情况是你们的设备：ch设备，此时就需要跟上ch设备文件名，否则安装以上方法倒入的仍然是c开头的设备：vgimport -v -m /tmp/vg01.map /dev/vg01   /dev/dsk/ch1t1d0   /dev/dsk/ch1t1d1 等。       这就需要你要导入的vg信息中到底包含哪些盘，这些盘在当前系统对应的设备文件ch设备名是多少，   没有map文件的情况：        这种情况下就必须要知道要导入的vg使用了那些硬盘，不管是ch设备还是c设备，因为这是没有map文件，就需要系统自己从这些硬盘的盘头读出这些信息，而不仅仅是像上一种方法一样仅仅是从map文件中读出vgid，然后匹配和这个id相同的硬盘。由于这种方法是从盘头读出信息，而盘头本身并没有vg下lv的名字的信息，所以导入后所有的lv变成lvol1  lvol2............等，这时就比较麻烦了，除非你知道原来的lv的名字及每个  
lv对应的0x0******的号码，然后将相同号码的lv  通过mv改名成你要的lv，否则就是数据都在你也没法用了。  
</code></pre><h3 id="19-vgcfgbackup">19. vgcfgbackup</h3>
<pre><code>vgcfgbackup [-f vg_conf_path] [-u] vg_name    
  
-f   将保存的vg的lvm配置信息保存到指定的路径中，默认情况为/etc/lvmconf/中   
  
例：   
vgcfgbackup -f /tmp/vg00.backup vg00   
  
注：    
该过程需要vg处于激活状态      
</code></pre><h3 id="20-vgcfgrestore">20. vgcfgrestore</h3>
<pre><code>vgcfgrestore -n vg_name -l    
vgcfgrestore [-R] [-F] -n vg_name [-o old_pv_path] pv_path   
vgcfgrestore -f vg_conf_path -l    
vgcfgrestore [-R] [-F] -f vg_conf_path [-o old_pv_path]   
恢复硬盘的VGRA信息。   
  
-n  指定的vg的名称   
-F  强制执行   
-l  显示配置信息    
-R  强制执行，即使vg处于激活状态   
  
向c0t4d0上加载lvm配置信息    
vgcfgrestore -f /tmp/vg00.backup /dev/rdsk/c0t4d0   
  
注：    
该操作仅恢复硬盘的VGRA区域，并不恢复其他区域，要求盘头包含lvmrec的信息，即该盘被pvcreate了，否则会报该盘不包含可用的lvmrec信息。要求该pv所属的vg信息在lvmtab中，且该vg的设备文件信息在/dev下，也就说该vg不能被export掉。  该操作要求vg处于非激活状态  用于恢复的文件中需要包含有该pv的信息，如果使用的文件不包含该pv，则无法恢复成功。  
</code></pre><h3 id="21-vgscan">21. vgscan</h3>
<pre><code>注：    
该命令用于扫描盘头，更新lvmtab表，过程如下：首先它搜索每个PV，读取其VGID，和lvmtab中的VGID进行比较，如果lvmtab中有该VGID，则跳过不作任何操作，如没有则查找内存，根据VGID找到相应的group文件的mag number，并基于此找到相应的VG名称，更新lvmtab，所以说vgscan是在线修复lvmtab的最后一步，如果机器重起，或者由于其他原因造成内存中该vg的信息发生变化，将无法用此命令修复lvmtab.也就是说要恢复的vg 必须正在或者曾经在系统中激活过。  我们可以假设一种情况，一个vg包含两个pv，其中一个损坏，且无法reduce掉，即VGRA中包含的pv信息没有变化，我们把lvmtab mv掉，重新vgscan，生成新的lvmtab,但此时  
只能找回一个pv,激活vg时当然会报错，另外vgdisplay我们将看到act pv （少一）数和cur pv数不一致，即vg盘头信息中应该包含的pv数和内存中的数目不一致。   
</code></pre><h3 id="22-newfs">22. newfs</h3>
<pre><code>newfs [-F FStype] [-o specific_options] [-V] special   
创建文件系统   
-F  创建文件系统的类型（默认参数由/etc/default/fs定义）   
-o  文件系统的类型   
-v  显示执行过程及结果    
  
例：   
newfs -F hfs /dev/rdsk/c1t0d2   :在整个硬盘上创建文件系统   
newfs –F vxfs –o largefiles /dev/vg01/rdata  在一个lv上创建，并支持大文件系统 注：   
该命令将重新刷新文件系统的目录树结构，整个文件系统将显示为空，此时实际的数据还在，如果之前用metasave命令曾经备份过文件系统结构信息，可以用metasave命令重新恢复该信息。但如果newfs后有新的数据读写，即使恢复回去，文件系统仍将被破坏。   
如果对现有的文件系统或lv重新执行newfs，一定要确保该lv上的数据为无用数据或已经备份。
</code></pre><h3 id="23-fsck">23. fsck</h3>
<pre><code>文件系统的一致性检测并进行恢复   
fsck [-F FSType] [-m] [-V] [special ...]   
fsck [-F FSType] [-o FSspecific-options] [-V] [special ...]   
-F   文件系统的类型   
-m  只进行完整性检查   
-o  定义类型   
 y  进行全数据校验   
-v  显示执行过程及结果    
我们目前使用的文件主要包括hfs 非日志性文件系统和vxfs日志性文件系统。 文件系统进行写入操作过程如下：   
日志文件系统有一个循环使用的日志域，可以用来记录每次磁盘事务的状态。任何磁盘结构改动前都要写一个目的改变（intent-to-change）记录到日志。然后才改变目录结构，完成后，此日志条目被标记为完成。   
当文件系统在进行io读写过程中出现异常umount（如reboot主机或主机异常down掉）， 由于文件系统的所有改动都记录在日志中，我们就可以通过查看日志来检查文件系统的一致性，而不必扫描整个文件系统。在挂载时，如果找到一个目的改变条目，而且它没有标记为clean，则检查那个块对应的文件结构，并在需要时进行调整。   
而非日志性文件系统则需要对整个文件系统的各个数据元进行扫描校验，所以这个过程就可能比较长。   
另一方面用户写数据的时候，实际上并不立即发生写磁盘的动作，数据会被拷贝到一个内存的缓冲区里。数据同inode信息一起，会在以后的一些时间被写到磁盘上，通常是在缓冲区满的时候和新需要清除一下缓冲空间的时候。如果系统在还没有将缓冲区中的信息写到磁盘上去之前，系统关闭。文件系统的一致性就会被破坏。这有些像数据库的异步io方式。 如果fsck检查到一个文件系统不完整，它会报告这个问题，然后询问是否对其进行修复。如果你回答”yes”，fsck会试图修正这个问题。如果你回答“no”，fsck会忽略这个问题，继续进行检查。一般都要选择&quot;yes&quot;，让系统自动修复发现的问题。   
为了修正文件系统的错误，fsck会删除一个或者多个文件，观察fsck输出的”REMOVE&quot;的信息，确保从磁带上恢复受影响的文件。   
fsck将所有检查有问题的文件放在lost+found目录下。在fsck完成之后，你应该检查这个目录的内容。文件名是以inode号来命名。   
fsck会重新链接孤儿文件。如果和看到任何重链接的信息，检查文件系统的lost+found目录。    
</code></pre><h3 id="24-mount">24. mount</h3>
<pre><code>加载文件系统点   
mount  -o  ro   /dev/dsk/c0t1d0(光驱的设备文件)  /cdrom   以只读方式加载光驱   
mount /dev/vg01/mydata  /mydata   
mount –a   加载fstab中定义的所有的文件系统   
  
注：   
Mount之前系统会检测文件系统的状态，如果发现不正常会提示需要进行fsck。    
</code></pre><h3 id="25-umount">25. umount</h3>
<pre><code>卸载文件系统的mount点 例   
umont /cdrom   
umount /opt                       &lt;卸除opt&gt;   
  
注：   
Umount 时需要改文件系统处于空闲状态，否则将提示device busy，需要使用fuser /目录检查有哪些程序在使用该文件系统，然后停掉相应进程。   
异常关闭正在进行IO写操作的进程也可能造成文件系统不一致。 Umount 时会对lv有个回写的操作，所以要求lv的状态正常能够进行访问，否则会报io 错误无法umount。
</code></pre>
        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://anTtutu.github.io/">Anttu</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://anTtutu.github.io/post/2017-05-21-lvm-vxvm/">https://anTtutu.github.io/post/2017-05-21-lvm-vxvm/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/2017-05-21-lvm-vxvm3/">VCS第七波-磁阵管理LVM和VxVM3-LVM</a></li>
        
        <li><a href="/post/2017-05-21-lvm-vxvm2/">VCS第六波-磁阵管理LVM和VxVM2-VxVM</a></li>
        
        <li><a href="/post/2017-05-15-vcs4/">VCS第四波-main.cf解读</a></li>
        
        <li><a href="/post/2017-05-14-vcs3/">VCS第三波-VCS的模块工作原理</a></li>
        
        <li><a href="/post/2017-05-13-vcs2/">VCS第二波-命令管理</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://anTtutu.github.io/tags/vcs'>vcs</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "anTtutu/anTtutu.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://anTtutu.github.io/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://anTtutu.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://anTtutu.github.io/post/2020-08-19-mine_virus/" title="分析挖矿病毒">分析挖矿病毒</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2020-02-13-hugo_blog/" title="改用最快的静态blog-hugo">改用最快的静态blog-hugo</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2020-02-11-Golang_study_01/" title="Golang学习笔记01 - 关键字和基础数据类型介绍">Golang学习笔记01 - 关键字和基础数据类型介绍</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2020-01-07-redis_batch_import/" title="30W数据批量导入redis集群">30W数据批量导入redis集群</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2019-12-21-mysql_expansion/" title="mysql集群在线无损扩容">mysql集群在线无损扩容</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2019-03-26-mysql_data_restore/" title="被同事误删表找回丢失的数据">被同事误删表找回丢失的数据</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2019-03-11-jdkbug/" title="JDK1.8.0.161版本bug定位">JDK1.8.0.161版本bug定位</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2018-04-10-OrangePi/" title="OrangePi">OrangePi</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2017-09-12-cygwin_install/" title="Cygwin安装">Cygwin安装</a>
    </li>
    
    <li>
        <a href="https://anTtutu.github.io/post/2017-08-27-java_use_note/" title="java小日常记录-不定期更新">java小日常记录-不定期更新</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="https://anTtutu.github.io/categories/JDK%E7%9A%84bug/">JDK的bug (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/OrangePi/">OrangePi (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/about/">about (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/blog/">blog (2)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/cygwin/">cygwin (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/gitment/">gitment (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/golang/">golang (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/h2/">h2 (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/hugo/">hugo (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/java/">java (5)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/jekyll/">jekyll (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/js/">js (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/linux/">linux (2)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/log4j/">log4j (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/mysql/">mysql (2)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/oracle/">oracle (3)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/redis/">redis (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/reids/">reids (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/shell/">shell (2)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/sqlmap/">sqlmap (1)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/vcs/">vcs (7)</a></li>
    
    <li><a href="https://anTtutu.github.io/categories/virus/">virus (1)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://anTtutu.github.io/tags/JDK%E7%9A%84bug/">JDK的bug</a>
    
    <a href="https://anTtutu.github.io/tags/OrangePi/">OrangePi</a>
    
    <a href="https://anTtutu.github.io/tags/about/">about</a>
    
    <a href="https://anTtutu.github.io/tags/blog/">blog</a>
    
    <a href="https://anTtutu.github.io/tags/cygwin/">cygwin</a>
    
    <a href="https://anTtutu.github.io/tags/gitment/">gitment</a>
    
    <a href="https://anTtutu.github.io/tags/golang/">golang</a>
    
    <a href="https://anTtutu.github.io/tags/h2/">h2</a>
    
    <a href="https://anTtutu.github.io/tags/hugo/">hugo</a>
    
    <a href="https://anTtutu.github.io/tags/java/">java</a>
    
    <a href="https://anTtutu.github.io/tags/jekyll/">jekyll</a>
    
    <a href="https://anTtutu.github.io/tags/js/">js</a>
    
    <a href="https://anTtutu.github.io/tags/linux/">linux</a>
    
    <a href="https://anTtutu.github.io/tags/log4j/">log4j</a>
    
    <a href="https://anTtutu.github.io/tags/mine/">mine</a>
    
    <a href="https://anTtutu.github.io/tags/mysql/">mysql</a>
    
    <a href="https://anTtutu.github.io/tags/oracle/">oracle</a>
    
    <a href="https://anTtutu.github.io/tags/redis/">redis</a>
    
    <a href="https://anTtutu.github.io/tags/shell/">shell</a>
    
    <a href="https://anTtutu.github.io/tags/sqlmap/">sqlmap</a>
    
    <a href="https://anTtutu.github.io/tags/vcs/">vcs</a>
    
    <a href="https://anTtutu.github.io/tags/virus/">virus</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://anTtutu.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://anTtutu.github.io/">Anttu&#39;s Blog By Anttu</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>